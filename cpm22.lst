0001   0000             ;**************************************************************
0002   0000             ;*
0003   0000             ;*             C P / M   version   2 . 2
0004   0000             ;*
0005   0000             ;*   Reconstructed from memory image on February 27, 1981
0006   0000             ;*
0007   0000             ;*                by Clark A. Calkins
0008   0000             ;*
0009   0000             ;*      12/6/2017 Edits to make TASM happy. J.C.Lang
0010   0000             ;**************************************************************
0011   0000             	.PAGE
0012   0000             	.TITLE "CP/M Ver 2.2 CCP"
TASM Z80 Assembler.               cpm22.z80                        page 1
CP/M Ver 2.2 CCP

0013   0000             	.EJECT
0014   0000             ;**************************************************************
0015   0000             ; CP/M Version 2.2 Command Processor
0016   0000             ;**************************************************************
0017   0000             ;
0018   0000             ;   Set memory limit here. This is the amount of contigeous
0019   0000             ; ram starting from 0000. CP/M will reside at the end of this space.
0020   0000             ;
0021   0000             MEM	.EQU	62		;for a 62k system
0022   0000             ;
0023   0000             SYSDSK	.EQU	2		;system disk number(C:)
0024   0000             IOBYTE	.EQU	3		;i/o definition byte.
0025   0000             TDRIVE	.EQU	4		;current drive name and user number.
0026   0000             ENTRY	.EQU	5		;entry point for the cp/m bdos.
0027   0000             TFCB	.EQU	5CH		;default file control block.
0028   0000             TBUFF	.EQU	80H		;i/o buffer and command line storage.
0029   0000             TBASE	.EQU	100H		;transiant program storage area.
0030   0000             ;-------------------------------------------------------------
0031   0000             ;   Set control character equates.
0032   0000             ;
0033   0000             CNTRLC	.EQU	3		;control-c
0034   0000             CNTRLE	.EQU	05H		;control-e
0035   0000             BS	.EQU	08H		;backspace
0036   0000             TAB	.EQU	09H		;tab
0037   0000             LF	.EQU	0AH		;line feed
0038   0000             FF	.EQU	0CH		;form feed
0039   0000             CR	.EQU	0DH		;carriage return
0040   0000             CNTRLP	.EQU	10H		;control-p
0041   0000             CNTRLR	.EQU	12H		;control-r
0042   0000             CNTRLS	.EQU	13H		;control-s
0043   0000             CNTRLU	.EQU	15H		;control-u
0044   0000             CNTRLX	.EQU	18H		;control-x
0045   0000             CNTRLZ	.EQU	1AH		;control-z (end-of-file mark)
0046   0000             DEL	.EQU	7FH		;rubout
0047   0000             ;
0048   0000             ;   Set origin for CP/M
0049   0000             ;
0050   DC00             	.ORG	(MEM-7)*1024
0051   DC00             ;-------------------------------------------------------------
0052   DC00             ;
0053   DC00             CBASE:
0054   DC00 C3 5C DF    	JP	COMMAND		;execute command processor (ccp).
0055   DC03 C3 58 DF    	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
0056   DC06             
0057   DC06             ;
0058   DC06             ;   Standard cp/m ccp input buffer. Format is (max length),
0059   DC06             ; (actual length), (char #1), (char #2), (char #3), etc.
0060   DC06             ;
0061   DC06             INBUFF:
0062   DC06 7F          	.BYTE	127		;length of input buffer.
0063   DC07 00          	.BYTE	0		;current length of contents.
0064   DC08 43 6F 70 79 	.BYTE	"Copyright"
0064   DC0C 72 69 67 68 
0064   DC10 74 
0065   DC11 20 31 39 37 	.BYTE	" 1979 "
0065   DC15 39 20 
0066   DC17 28 63 29    	.BYTE	28h,63h,29h
0067   DC1A 20 62 79 20 	.BYTE	" by Digital Research      "
0067   DC1E 44 69 67 69 
TASM Z80 Assembler.               cpm22.z80                        page 2
CP/M Ver 2.2 CCP

0067   DC22 74 61 6C 20 
0067   DC26 52 65 73 65 
0067   DC2A 61 72 63 68 
0067   DC2E 20 20 20 20 
0067   DC32 20 20 
0068   DC34 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0068   DC38 00 00 00 00 
0069   DC3C 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0069   DC40 00 00 00 00 
0070   DC44 00 00 00 00 	.BYTE	0,0,0,0,0,0,0
0070   DC48 00 00 00 
0071   DC4B 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0071   DC4F 00 00 00 00 
0072   DC53 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0072   DC57 00 00 00 00 
0073   DC5B 00 00 00 00 	.BYTE	0,0,0,0,0,0,0
0073   DC5F 00 00 00 
0074   DC62 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0074   DC66 00 00 00 00 
0075   DC6A 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0075   DC6E 00 00 00 00 
0076   DC72 00 00 00 00 	.BYTE	0,0,0,0,0,0,0
0076   DC76 00 00 00 
0077   DC79 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
0077   DC7D 00 00 00 00 
0078   DC81 00 00 00 00 	.BYTE	0,0,0,0,0,0,0
0078   DC85 00 00 00 
0079   DC88             INPOINT:
0080   DC88 08 DC       	.WORD	INBUFF+2	;input line pointer
0081   DC8A             NAMEPNT:
0082   DC8A 00 00       	.WORD	0		;pointer used for error message.
0083   DC8C             				;Points to start of name in error.
0084   DC8C             ;
0085   DC8C             ;-------------------------------------------------------------
0086   DC8C             ;   Routine to print (A) on the console. All registers used.
0087   DC8C             ;
0088   DC8C             PRINT:
0089   DC8C 5F          	LD	E,A		;setup bdos call.
0090   DC8D 0E 02       	LD	C,2
0091   DC8F C3 05 00    	JP	ENTRY
0092   DC92             ;
0093   DC92             ;-------------------------------------------------------------
0094   DC92             ;   Routine to print (A) on the console and to save (BC).
0095   DC92             ;
0096   DC92             PRINTB:
0097   DC92 C5          	PUSH	BC
0098   DC93 CD 8C DC    	CALL	PRINT
0099   DC96 C1          	POP	BC
0100   DC97 C9          	RET	
0101   DC98             ;
0102   DC98             ;-------------------------------------------------------------
0103   DC98             ;   Routine to send a carriage return, line feed combination
0104   DC98             ; to the console.
0105   DC98             ;
0106   DC98             CRLF:
0107   DC98 3E 0D       	LD	A,CR
0108   DC9A CD 92 DC    	CALL	PRINTB
0109   DC9D 3E 0A       	LD	A,LF
0110   DC9F C3 92 DC    	JP	PRINTB
TASM Z80 Assembler.               cpm22.z80                        page 3
CP/M Ver 2.2 CCP

0111   DCA2             ;
0112   DCA2             ;-------------------------------------------------------------
0113   DCA2             ;   Routine to send one space to the console and save (BC).
0114   DCA2             ;
0115   DCA2             SPACE:
0116   DCA2 3E 20       	LD	A,' '
0117   DCA4 C3 92 DC    	JP	PRINTB
0118   DCA7             ;
0119   DCA7             ;-------------------------------------------------------------
0120   DCA7             ;   Routine to print character string pointed to be (BC) on the
0121   DCA7             ; console. It must terminate with a null byte.
0122   DCA7             ;
0123   DCA7             PLINE:
0124   DCA7 C5          	PUSH	BC
0125   DCA8 CD 98 DC    	CALL	CRLF
0126   DCAB E1          	POP	HL
0127   DCAC             PLINE2:
0128   DCAC 7E          	LD	A,(HL)
0129   DCAD B7          	OR	A
0130   DCAE C8          	RET	Z
0131   DCAF 23          	INC	HL
0132   DCB0 E5          	PUSH	HL
0133   DCB1 CD 8C DC    	CALL	PRINT
0134   DCB4 E1          	POP	HL
0135   DCB5 C3 AC DC    	JP	PLINE2
0136   DCB8             ;
0137   DCB8             ;-------------------------------------------------------------
0138   DCB8             ;   Routine to reset the disk system.
0139   DCB8             ;
0140   DCB8             RESDSK:
0141   DCB8 0E 0D       	LD	C,13
0142   DCBA C3 05 00    	JP	ENTRY
0143   DCBD             ;
0144   DCBD             ;-------------------------------------------------------------
0145   DCBD             ;   Routine to select disk (A).
0146   DCBD             ;
0147   DCBD             DSKSEL:
0148   DCBD 5F          	LD	E,A
0149   DCBE 0E 0E       	LD	C,14
0150   DCC0 C3 05 00    	JP	ENTRY
0151   DCC3             ;
0152   DCC3             ;-------------------------------------------------------------
0153   DCC3             ;   Routine to call bdos and save the return code. The zero
0154   DCC3             ; flag is set on a return of 0ffh.
0155   DCC3             ;
0156   DCC3             ENTRY1:
0157   DCC3 CD 05 00    	CALL	ENTRY
0158   DCC6 32 EE E3    	LD	(RTNCODE),A	;save return code.
0159   DCC9 3C          	INC	A		;set zero if 0ffh returned.
0160   DCCA C9          	RET	
0161   DCCB             ;
0162   DCCB             ;-------------------------------------------------------------
0163   DCCB             ;   Routine to open a file. (DE) must point to the FCB.
0164   DCCB             ;
0165   DCCB             OPEN:
0166   DCCB 0E 0F       	LD	C,15
0167   DCCD C3 C3 DC    	JP	ENTRY1
0168   DCD0             ;
0169   DCD0             ;-------------------------------------------------------------
TASM Z80 Assembler.               cpm22.z80                        page 4
CP/M Ver 2.2 CCP

0170   DCD0             ;   Routine to open file at (FCB).
0171   DCD0             ;
0172   DCD0             OPENFCB:
0173   DCD0 AF          	XOR	A		;clear the record number byte
0174   DCD1 32 ED E3    	LD	(FCB+32),A	;at fcb+32
0175   DCD4 11 CD E3    	LD	DE,FCB
0176   DCD7 C3 CB DC    	JP	OPEN
0177   DCDA             ;
0178   DCDA             ;-------------------------------------------------------------
0179   DCDA             ;   Routine to close a file. (DE) points to FCB.
0180   DCDA             ;
0181   DCDA             CLOSE:
0182   DCDA 0E 10       	LD	C,16
0183   DCDC C3 C3 DC    	JP	ENTRY1
0184   DCDF             ;
0185   DCDF             ;-------------------------------------------------------------
0186   DCDF             ;   Routine to search for the first file with ambigueous name
0187   DCDF             ; (DE).
0188   DCDF             ;
0189   DCDF             SRCHFST:
0190   DCDF 0E 11       	LD	C,17
0191   DCE1 C3 C3 DC    	JP	ENTRY1
0192   DCE4             ;
0193   DCE4             ;-------------------------------------------------------------
0194   DCE4             ;   Search for the next ambigeous file name.
0195   DCE4             ;
0196   DCE4             SRCHNXT:
0197   DCE4 0E 12       	LD	C,18
0198   DCE6 C3 C3 DC    	JP	ENTRY1
0199   DCE9             ;
0200   DCE9             ;-------------------------------------------------------------
0201   DCE9             ;   Search for file at (FCB).
0202   DCE9             ;
0203   DCE9             SRCHFCB:
0204   DCE9 11 CD E3    	LD	DE,FCB
0205   DCEC C3 DF DC    	JP	SRCHFST
0206   DCEF             ;
0207   DCEF             ;-------------------------------------------------------------
0208   DCEF             ;   Routine to delete a file pointed to by (DE).
0209   DCEF             ;
0210   DCEF             DELETE:
0211   DCEF 0E 13       	LD	C,19
0212   DCF1 C3 05 00    	JP	ENTRY
0213   DCF4             ;
0214   DCF4             ;-------------------------------------------------------------
0215   DCF4             ;   Routine to call the bdos and set the zero flag if a zero
0216   DCF4             ; status is returned.
0217   DCF4             ;
0218   DCF4             ENTRY2:
0219   DCF4 CD 05 00    	CALL	ENTRY
0220   DCF7 B7          	OR	A		;set zero flag if appropriate.
0221   DCF8 C9          	RET	
0222   DCF9             ;
0223   DCF9             ;-------------------------------------------------------------
0224   DCF9             ;   Routine to read the next record from a sequential file.
0225   DCF9             ; (DE) points to the FCB.
0226   DCF9             ;
0227   DCF9             RDREC:
0228   DCF9 0E 14       	LD	C,20
TASM Z80 Assembler.               cpm22.z80                        page 5
CP/M Ver 2.2 CCP

0229   DCFB C3 F4 DC    	JP	ENTRY2
0230   DCFE             ;
0231   DCFE             ;-------------------------------------------------------------
0232   DCFE             ;   Routine to read file at (FCB).
0233   DCFE             ;
0234   DCFE             READFCB:
0235   DCFE 11 CD E3    	LD	DE,FCB
0236   DD01 C3 F9 DC    	JP	RDREC
0237   DD04             ;
0238   DD04             ;-------------------------------------------------------------
0239   DD04             ;   Routine to write the next record of a sequential file.
0240   DD04             ; (DE) points to the FCB.
0241   DD04             ;
0242   DD04             WRTREC:
0243   DD04 0E 15       	LD	C,21
0244   DD06 C3 F4 DC    	JP	ENTRY2
0245   DD09             ;
0246   DD09             ;-------------------------------------------------------------
0247   DD09             ;   Routine to create the file pointed to by (DE).
0248   DD09             ;
0249   DD09             CREATE:
0250   DD09 0E 16       	LD	C,22
0251   DD0B C3 C3 DC    	JP	ENTRY1
0252   DD0E             ;
0253   DD0E             ;-------------------------------------------------------------
0254   DD0E             ;   Routine to rename the file pointed to by (DE). Note that
0255   DD0E             ; the new name starts at (DE+16).
0256   DD0E             ;
0257   DD0E             RENAM:
0258   DD0E 0E 17       	LD	C,23
0259   DD10 C3 05 00    	JP	ENTRY
0260   DD13             ;
0261   DD13             ;-------------------------------------------------------------
0262   DD13             ;   Get the current user code.
0263   DD13             ;
0264   DD13             GETUSR:
0265   DD13 1E FF       	LD	E,0FFH
0266   DD15             ;
0267   DD15             ;-------------------------------------------------------------
0268   DD15             ;   Routne to get or set the current user code.
0269   DD15             ; If (E) is FF then this is a GET, else it is a SET.
0270   DD15             ;
0271   DD15             GETSETUC:
0272   DD15 0E 20       	 LD	C,32
0273   DD17 C3 05 00    	JP	ENTRY
0274   DD1A             ;
0275   DD1A             ;-------------------------------------------------------------
0276   DD1A             ;   Routine to set the current drive byte at (TDRIVE).
0277   DD1A             ;
0278   DD1A             SETCDRV:
0279   DD1A CD 13 DD    	CALL	GETUSR		;get user number
0280   DD1D 87          	ADD	A,A		;and shift into the upper 4 bits.
0281   DD1E 87          	ADD	A,A
0282   DD1F 87          	ADD	A,A
0283   DD20 87          	ADD	A,A
0284   DD21 21 EF E3    	LD	HL,CDRIVE	;add in the current drive number.
0285   DD24 B6          	OR	(HL)
0286   DD25 32 04 00    	LD	(TDRIVE),A	;and save.
0287   DD28 C9          	RET	
TASM Z80 Assembler.               cpm22.z80                        page 6
CP/M Ver 2.2 CCP

0288   DD29             ;
0289   DD29             ;-------------------------------------------------------------
0290   DD29             ;   Move currently active drive down to (TDRIVE).
0291   DD29             ;
0292   DD29             MOVECD:
0293   DD29 3A EF E3    	LD	A,(CDRIVE)
0294   DD2C 32 04 00    	LD	(TDRIVE),A
0295   DD2F C9          	RET	
0296   DD30             ;
0297   DD30             ;-------------------------------------------------------------
0298   DD30             ;   Routine to convert (A) into upper case ascii. Only letters
0299   DD30             ; are affected.
0300   DD30             ;
0301   DD30             UPPER:
0302   DD30 FE 61       	CP	'a'		;letters in the range of 'a' to 'z'?
0303   DD32 D8          	RET	C
0304   DD33 FE 7B       	CP	'{'
0305   DD35 D0          	RET	NC
0306   DD36 E6 5F       	AND	5FH		;convert to lower case if found.
0307   DD38 C9          	RET	
0308   DD39             ;
0309   DD39             ;-------------------------------------------------------------
0310   DD39             ;   Routine to get a line of input. We must check to see if the
0311   DD39             ; user is in (BATCH) mode. If so, then read the input from file
0312   DD39             ; ($$$.SUB). At the end, reset to console input.
0313   DD39             ;
0314   DD39             GETINP:
0315   DD39 3A AB E3    	LD	A,(BATCH)	;if =0, then use console input.
0316   DD3C B7          	OR	A
0317   DD3D CA 96 DD    	JP	Z,GETINP1
0318   DD40             ;
0319   DD40             ;   Use the submit file ($$$.sub) which is prepared by a
0320   DD40             ; SUBMIT run. It must be on drive (A) and it will be deleted
0321   DD40             ; if and error occures (like eof).
0322   DD40             ;
0323   DD40 3A EF E3    	LD	A,(CDRIVE)	;select drive 0 if need be.
0324   DD43 B7          	OR	A
0325   DD44 3E 00       	LD	A,0		;always use drive A for submit.
0326   DD46 C4 BD DC    	CALL	NZ,DSKSEL	;select it if required.
0327   DD49 11 AC E3    	LD	DE,BATCHFCB
0328   DD4C CD CB DC    	CALL	OPEN		;look for it.
0329   DD4F CA 96 DD    	JP	Z,GETINP1	;if not there, use normal input.
0330   DD52 3A BB E3    	LD	A,(BATCHFCB+15)	;get last record number+1.
0331   DD55 3D          	DEC	A
0332   DD56 32 CC E3    	LD	(BATCHFCB+32),A
0333   DD59 11 AC E3    	LD	DE,BATCHFCB
0334   DD5C CD F9 DC    	CALL	RDREC		;read last record.
0335   DD5F C2 96 DD    	JP	NZ,GETINP1	;quit on end of file.
0336   DD62             ;
0337   DD62             ;   Move this record into input buffer.
0338   DD62             ;
0339   DD62 11 07 DC    	LD	DE,INBUFF+1
0340   DD65 21 80 00    	LD	HL,TBUFF	;data was read into buffer here.
0341   DD68 06 80       	LD	B,128		;all 128 characters may be used.
0342   DD6A CD 42 E0    	CALL	HL2DE		;(HL) to (DE), (B) bytes.
0343   DD6D 21 BA E3    	LD	HL,BATCHFCB+14
0344   DD70 36 00       	LD	(HL),0		;zero out the 's2' byte.
0345   DD72 23          	INC	HL		;and decrement the record count.
0346   DD73 35          	DEC	(HL)
TASM Z80 Assembler.               cpm22.z80                        page 7
CP/M Ver 2.2 CCP

0347   DD74 11 AC E3    	LD	DE,BATCHFCB	;close the batch file now.
0348   DD77 CD DA DC    	CALL	CLOSE
0349   DD7A CA 96 DD    	JP	Z,GETINP1	;quit on an error.
0350   DD7D 3A EF E3    	LD	A,(CDRIVE)	;re-select previous drive if need be.
0351   DD80 B7          	OR	A
0352   DD81 C4 BD DC    	CALL	NZ,DSKSEL	;don't do needless selects.
0353   DD84             ;
0354   DD84             ;   Print line just read on console.
0355   DD84             ;
0356   DD84 21 08 DC    	LD	HL,INBUFF+2
0357   DD87 CD AC DC    	CALL	PLINE2
0358   DD8A CD C2 DD    	CALL	CHKCON		;check console, quit on a key.
0359   DD8D CA A7 DD    	JP	Z,GETINP2	;jump if no key is pressed.
0360   DD90             ;
0361   DD90             ;   Terminate the submit job on any keyboard input. Delete this
0362   DD90             ; file such that it is not re-started and jump to normal keyboard
0363   DD90             ; input section.
0364   DD90             ;
0365   DD90 CD DD DD    	CALL	DELBATCH	;delete the batch file.
0366   DD93 C3 82 DF    	JP	CMMND1		;and restart command input.
0367   DD96             ;
0368   DD96             ;   Get here for normal keyboard input. Delete the submit file
0369   DD96             ; incase there was one.
0370   DD96             ;
0371   DD96             GETINP1:
0372   DD96 CD DD DD    	CALL	DELBATCH	;delete file ($$$.sub).
0373   DD99 CD 1A DD    	CALL	SETCDRV		;reset active disk.
0374   DD9C 0E 0A       	LD	C,10		;get line from console device.
0375   DD9E 11 06 DC    	LD	DE,INBUFF
0376   DDA1 CD 05 00    	CALL	ENTRY
0377   DDA4 CD 29 DD    	CALL	MOVECD		;reset current drive (again).
0378   DDA7             ;
0379   DDA7             ;   Convert input line to upper case.
0380   DDA7             ;
0381   DDA7             GETINP2:
0382   DDA7 21 07 DC    	LD	HL,INBUFF+1
0383   DDAA 46          	LD	B,(HL)		;(B)=character counter.
0384   DDAB             GETINP3:
0385   DDAB 23          	INC	HL
0386   DDAC 78          	LD	A,B		;end of the line?
0387   DDAD B7          	OR	A
0388   DDAE CA BA DD    	JP	Z,GETINP4
0389   DDB1 7E          	LD	A,(HL)		;convert to upper case.
0390   DDB2 CD 30 DD    	CALL	UPPER
0391   DDB5 77          	LD	(HL),A
0392   DDB6 05          	DEC	B		;adjust character count.
0393   DDB7 C3 AB DD    	JP	GETINP3
0394   DDBA             GETINP4:
0395   DDBA 77          	LD	(HL),A		;add trailing null.
0396   DDBB 21 08 DC    	LD	HL,INBUFF+2
0397   DDBE 22 88 DC    	LD	(INPOINT),HL	;reset input line pointer.
0398   DDC1 C9          	RET	
0399   DDC2             ;
0400   DDC2             ;-------------------------------------------------------------
0401   DDC2             ;   Routine to check the console for a key pressed. The zero
0402   DDC2             ; flag is set is none, else the character is returned in (A).
0403   DDC2             ;
0404   DDC2             CHKCON:
0405   DDC2 0E 0B       	LD	C,11		;check console.
TASM Z80 Assembler.               cpm22.z80                        page 8
CP/M Ver 2.2 CCP

0406   DDC4 CD 05 00    	CALL	ENTRY
0407   DDC7 B7          	OR	A
0408   DDC8 C8          	RET	Z		;return if nothing.
0409   DDC9 0E 01       	LD	C,1		;else get character.
0410   DDCB CD 05 00    	CALL	ENTRY
0411   DDCE B7          	OR	A		;clear zero flag and return.
0412   DDCF C9          	RET	
0413   DDD0             ;
0414   DDD0             ;-------------------------------------------------------------
0415   DDD0             ;   Routine to get the currently active drive number.
0416   DDD0             ;
0417   DDD0             GETDSK:
0418   DDD0 0E 19       	LD	C,25
0419   DDD2 C3 05 00    	JP	ENTRY
0420   DDD5             ;
0421   DDD5             ;-------------------------------------------------------------
0422   DDD5             ;   Set the standard dma address.
0423   DDD5             ;
0424   DDD5             STDDMA:
0425   DDD5 11 80 00    	LD	DE,TBUFF
0426   DDD8             ;
0427   DDD8             ;-------------------------------------------------------------
0428   DDD8             ;   Routine to set the dma address to (DE).
0429   DDD8             ;
0430   DDD8             DMASET:
0431   DDD8 0E 1A       	LD	C,26
0432   DDDA C3 05 00    	JP	ENTRY
0433   DDDD             ;
0434   DDDD             ;-------------------------------------------------------------
0435   DDDD             ;  Delete the batch file created by SUBMIT.
0436   DDDD             ;
0437   DDDD             DELBATCH:
0438   DDDD 21 AB E3    	 LD	HL,BATCH	;is batch active?
0439   DDE0 7E          	LD	A,(HL)
0440   DDE1 B7          	OR	A
0441   DDE2 C8          	RET	Z
0442   DDE3 36 00       	LD	(HL),0		;yes, de-activate it.
0443   DDE5 AF          	XOR	A
0444   DDE6 CD BD DC    	CALL	DSKSEL		;select drive 0 for sure.
0445   DDE9 11 AC E3    	LD	DE,BATCHFCB	;and delete this file.
0446   DDEC CD EF DC    	CALL	DELETE
0447   DDEF 3A EF E3    	LD	A,(CDRIVE)	;reset current drive.
0448   DDF2 C3 BD DC    	JP	DSKSEL
0449   DDF5             ;
0450   DDF5             ;-------------------------------------------------------------
0451   DDF5             ;   Check the CCP and BDOS serial numbers
0452   DDF5             ;  They must be the same or we halt....
0453   DDF5             ;  (anti piracy protection?) (it didn't work)
0454   DDF5             ;
0455   DDF5             VERIFY:
0456   DDF5 11 28 DF    	LD	DE,PATTRN1	;CCP serial number bytes.
0457   DDF8 21 00 E4    	LD	HL,PATTRN2	;BDOS serial number bytes
0458   DDFB 06 06       	LD	B,6		;6 bytes each.
0459   DDFD             VERIFY1:
0460   DDFD 1A          	LD	A,(DE)
0461   DDFE BE          	CP	(HL)
0462   DDFF C2 CF DF    	JP	NZ,HALT		;jump to halt routine.
0463   DE02 13          	INC	DE
0464   DE03 23          	INC	HL
TASM Z80 Assembler.               cpm22.z80                        page 9
CP/M Ver 2.2 CCP

0465   DE04 05          	DEC	B
0466   DE05 C2 FD DD    	JP	NZ,VERIFY1
0467   DE08 C9          	RET	
0468   DE09             ;
0469   DE09             ;-------------------------------------------------------------
0470   DE09             ;   Print back file name with a '?' to indicate a syntax error.
0471   DE09             ;
0472   DE09             SYNERR:
0473   DE09 CD 98 DC    	CALL	CRLF		;end current line.
0474   DE0C 2A 8A DC    	LD	HL,(NAMEPNT)	;this points to name in error.
0475   DE0F             SYNERR1:
0476   DE0F 7E          	LD	A,(HL)		;print it until a space or null is found.
0477   DE10 FE 20       	CP	' '
0478   DE12 CA 22 DE    	JP	Z,SYNERR2
0479   DE15 B7          	OR	A
0480   DE16 CA 22 DE    	JP	Z,SYNERR2
0481   DE19 E5          	PUSH	HL
0482   DE1A CD 8C DC    	CALL	PRINT
0483   DE1D E1          	POP	HL
0484   DE1E 23          	INC	HL
0485   DE1F C3 0F DE    	JP	SYNERR1
0486   DE22             SYNERR2:
0487   DE22 3E 3F       	LD	A,'?'		;add trailing '?'.
0488   DE24 CD 8C DC    	CALL	PRINT
0489   DE27 CD 98 DC    	CALL	CRLF
0490   DE2A CD DD DD    	CALL	DELBATCH	;delete any batch file.
0491   DE2D C3 82 DF    	JP	CMMND1		;and restart from console input.
0492   DE30             ;
0493   DE30             ;-------------------------------------------------------------
0494   DE30             ;   Check character at (DE) for legal command input. Note that the
0495   DE30             ; zero flag is set if the character is a delimiter.
0496   DE30             ;
0497   DE30             CHECK:
0498   DE30 1A          	LD	A,(DE)
0499   DE31 B7          	OR	A
0500   DE32 C8          	RET	Z
0501   DE33 FE 20       	CP	' '		;control characters are not legal here.
0502   DE35 DA 09 DE    	JP	C,SYNERR
0503   DE38 C8          	RET	Z		;check for valid delimiter.
0504   DE39 FE 3D       	CP	'='
0505   DE3B C8          	RET	Z
0506   DE3C FE 5F       	CP	'_'
0507   DE3E C8          	RET	Z
0508   DE3F FE 2E       	CP	'.'
0509   DE41 C8          	RET	Z
0510   DE42 FE 3A       	CP	':'
0511   DE44 C8          	RET	Z
0512   DE45 FE 3B       	CP	3bh	;';'
0513   DE47 C8          	RET	Z
0514   DE48 FE 3C       	CP	'<'
0515   DE4A C8          	RET	Z
0516   DE4B FE 3E       	CP	'>'
0517   DE4D C8          	RET	Z
0518   DE4E C9          	RET	
0519   DE4F             ;
0520   DE4F             ;-------------------------------------------------------------
0521   DE4F             ;   Get the next non-blank character from (DE).
0522   DE4F             ;
0523   DE4F             NONBLANK:
TASM Z80 Assembler.               cpm22.z80                        page 10
CP/M Ver 2.2 CCP

0524   DE4F 1A          	LD	A,(DE)
0525   DE50 B7          	OR	A		;string ends with a null.
0526   DE51 C8          	RET	Z
0527   DE52 FE 20       	CP	' '
0528   DE54 C0          	RET	NZ
0529   DE55 13          	INC	DE
0530   DE56 C3 4F DE    	JP	NONBLANK
0531   DE59             ;
0532   DE59             ;-------------------------------------------------------------
0533   DE59             ;   Add (HL)=(HL)+(A)
0534   DE59             ;
0535   DE59             ADDHL:
0536   DE59 85          	ADD	A,L
0537   DE5A 6F          	LD	L,A
0538   DE5B D0          	RET	NC		;take care of any carry.
0539   DE5C 24          	INC	H
0540   DE5D C9          	RET	
0541   DE5E             ;
0542   DE5E             ;-------------------------------------------------------------
0543   DE5E             ;   Convert the first name in (FCB).
0544   DE5E             ;
0545   DE5E             CONVFST:
0546   DE5E 3E 00       	LD	A,0
0547   DE60             ;
0548   DE60             ;-------------------------------------------------------------
0549   DE60             ;   Format a file name (convert * to '?', etc.). On return,
0550   DE60             ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0551   DE60             ; the position within the fcb for the name (either 0 or 16).
0552   DE60             ;
0553   DE60             CONVERT:
0554   DE60 21 CD E3    	LD	HL,FCB
0555   DE63 CD 59 DE    	CALL	ADDHL
0556   DE66 E5          	PUSH	HL
0557   DE67 E5          	PUSH	HL
0558   DE68 AF          	XOR	A
0559   DE69 32 F0 E3    	LD	(CHGDRV),A	;initialize drive change flag.
0560   DE6C 2A 88 DC    	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
0561   DE6F EB          	EX	DE,HL
0562   DE70 CD 4F DE    	CALL	NONBLANK	;get next non-blank character.
0563   DE73 EB          	EX	DE,HL
0564   DE74 22 8A DC    	LD	(NAMEPNT),HL	;save pointer here for any error message.
0565   DE77 EB          	EX	DE,HL
0566   DE78 E1          	POP	HL
0567   DE79 1A          	LD	A,(DE)		;get first character.
0568   DE7A B7          	OR	A
0569   DE7B CA 89 DE    	JP	Z,CONVRT1
0570   DE7E DE 40       	SBC	A,'A'-1		;might be a drive name, convert to binary.
0571   DE80 47          	LD	B,A		;and save.
0572   DE81 13          	INC	DE		;check next character for a ':'.
0573   DE82 1A          	LD	A,(DE)
0574   DE83 FE 3A       	CP	':'
0575   DE85 CA 90 DE    	JP	Z,CONVRT2
0576   DE88 1B          	DEC	DE		;move pointer back to the start of the line.
0577   DE89             CONVRT1:
0578   DE89 3A EF E3    	LD	A,(CDRIVE)
0579   DE8C 77          	LD	(HL),A
0580   DE8D C3 96 DE    	JP	CONVRT3
0581   DE90             CONVRT2:
0582   DE90 78          	LD	A,B
TASM Z80 Assembler.               cpm22.z80                        page 11
CP/M Ver 2.2 CCP

0583   DE91 32 F0 E3    	LD	(CHGDRV),A	;set change in drives flag.
0584   DE94 70          	LD	(HL),B
0585   DE95 13          	INC	DE
0586   DE96             ;
0587   DE96             ;   Convert the basic file name.
0588   DE96             ;
0589   DE96             CONVRT3:
0590   DE96 06 08       	LD	B,08H
0591   DE98             CONVRT4:
0592   DE98 CD 30 DE    	CALL	CHECK
0593   DE9B CA B9 DE    	JP	Z,CONVRT8
0594   DE9E 23          	INC	HL
0595   DE9F FE 2A       	CP	'*'		;note that an '*' will fill the remaining
0596   DEA1 C2 A9 DE    	JP	NZ,CONVRT5	;field with '?'.
0597   DEA4 36 3F       	LD	(HL),'?'
0598   DEA6 C3 AB DE    	JP	CONVRT6
0599   DEA9             CONVRT5:
0600   DEA9 77          	LD	(HL),A
0601   DEAA 13          	INC	DE
0602   DEAB             CONVRT6:
0603   DEAB 05          	DEC	B
0604   DEAC C2 98 DE    	JP	NZ,CONVRT4
0605   DEAF             CONVRT7:
0606   DEAF CD 30 DE    	CALL	CHECK		;get next delimiter.
0607   DEB2 CA C0 DE    	JP	Z,GETEXT
0608   DEB5 13          	INC	DE
0609   DEB6 C3 AF DE    	JP	CONVRT7
0610   DEB9             CONVRT8:
0611   DEB9 23          	INC	HL		;blank fill the file name.
0612   DEBA 36 20       	LD	(HL),' '
0613   DEBC 05          	DEC	B
0614   DEBD C2 B9 DE    	JP	NZ,CONVRT8
0615   DEC0             ;
0616   DEC0             ;   Get the extension and convert it.
0617   DEC0             ;
0618   DEC0             GETEXT:
0619   DEC0 06 03       	LD	B,03H
0620   DEC2 FE 2E       	CP	'.'
0621   DEC4 C2 E9 DE    	JP	NZ,GETEXT5
0622   DEC7 13          	INC	DE
0623   DEC8             GETEXT1:
0624   DEC8 CD 30 DE    	CALL	CHECK
0625   DECB CA E9 DE    	JP	Z,GETEXT5
0626   DECE 23          	INC	HL
0627   DECF FE 2A       	CP	'*'
0628   DED1 C2 D9 DE    	JP	NZ,GETEXT2
0629   DED4 36 3F       	LD	(HL),'?'
0630   DED6 C3 DB DE    	JP	GETEXT3
0631   DED9             GETEXT2:
0632   DED9 77          	LD	(HL),A
0633   DEDA 13          	INC	DE
0634   DEDB             GETEXT3:
0635   DEDB 05          	DEC	B
0636   DEDC C2 C8 DE    	JP	NZ,GETEXT1
0637   DEDF             GETEXT4:
0638   DEDF CD 30 DE    	CALL	CHECK
0639   DEE2 CA F0 DE    	JP	Z,GETEXT6
0640   DEE5 13          	INC	DE
0641   DEE6 C3 DF DE    	JP	GETEXT4
TASM Z80 Assembler.               cpm22.z80                        page 12
CP/M Ver 2.2 CCP

0642   DEE9             GETEXT5:
0643   DEE9 23          	INC	HL
0644   DEEA 36 20       	LD	(HL),' '
0645   DEEC 05          	DEC	B
0646   DEED C2 E9 DE    	JP	NZ,GETEXT5
0647   DEF0             GETEXT6:
0648   DEF0 06 03       	LD	B,3
0649   DEF2             GETEXT7:
0650   DEF2 23          	INC	HL
0651   DEF3 36 00       	LD	(HL),0
0652   DEF5 05          	DEC	B
0653   DEF6 C2 F2 DE    	JP	NZ,GETEXT7
0654   DEF9 EB          	EX	DE,HL
0655   DEFA 22 88 DC    	LD	(INPOINT),HL	;save input line pointer.
0656   DEFD E1          	POP	HL
0657   DEFE             ;
0658   DEFE             ;   Check to see if this is an ambigeous file name specification.
0659   DEFE             ; Set the (A) register to non zero if it is.
0660   DEFE             ;
0661   DEFE 01 0B 00    	LD	BC,11		;set name length.
0662   DF01             GETEXT8:
0663   DF01 23          	INC	HL
0664   DF02 7E          	LD	A,(HL)
0665   DF03 FE 3F       	CP	'?'		;any question marks?
0666   DF05 C2 09 DF    	JP	NZ,GETEXT9
0667   DF08 04          	INC	B		;count them.
0668   DF09             GETEXT9:
0669   DF09 0D          	DEC	C
0670   DF0A C2 01 DF    	JP	NZ,GETEXT8
0671   DF0D 78          	LD	A,B
0672   DF0E B7          	OR	A
0673   DF0F C9          	RET	
0674   DF10             ;
0675   DF10             ;-------------------------------------------------------------
0676   DF10             ;   CP/M command table.
0677   DF10             ;   Note commands can be either 3 or 4 characters long.
0678   DF10             ;
0679   DF10             NUMCMDS .EQU	6		;number of commands
0680   DF10             CMDTBL:
0681   DF10 44 49 52 20 	.BYTE	"DIR "
0682   DF14 45 52 41 20 	.BYTE	"ERA "
0683   DF18 54 59 50 45 	.BYTE	"TYPE"
0684   DF1C 53 41 56 45 	.BYTE	"SAVE"
0685   DF20 52 45 4E 20 	.BYTE	"REN "
0686   DF24 55 53 45 52 	.BYTE	"USER"
0687   DF28             ;
0688   DF28             ;-------------------------------------------------------------
0689   DF28             ; PATTRN1 is the CCP serial number
0690   DF28             ; PATTRN2 is the BDOS serial number
0691   DF28             ; They must match
0692   DF28             ;
0693   DF28             PATTRN1:
0694   DF28 00 16 00 00 	.BYTE	0,22,0,0,0,0	;(* serial number bytes *).
0694   DF2C 00 00 
0695   DF2E             ;
0696   DF2E             ;-------------------------------------------------------------
0697   DF2E             ;   Search the command table for a match with what has just
0698   DF2E             ; been entered. If a match is found, then we jump to the
0699   DF2E             ; proper section. Else jump to (UNKNOWN).
TASM Z80 Assembler.               cpm22.z80                        page 13
CP/M Ver 2.2 CCP

0700   DF2E             ; On return, the (C) register is set to the command number
0701   DF2E             ; that matched (or NUMCMDS+1 if no match).
0702   DF2E             ;
0703   DF2E             SEARCH:
0704   DF2E 21 10 DF    	LD	HL,CMDTBL
0705   DF31 0E 00       	LD	C,0
0706   DF33             SEARCH1:
0707   DF33 79          	LD	A,C
0708   DF34 FE 06       	CP	NUMCMDS		;this commands exists.
0709   DF36 D0          	RET	NC
0710   DF37 11 CE E3    	LD	DE,FCB+1	;check this one.
0711   DF3A 06 04       	LD	B,4		;max command length.
0712   DF3C             SEARCH2:
0713   DF3C 1A          	LD	A,(DE)
0714   DF3D BE          	CP	(HL)
0715   DF3E C2 4F DF    	JP	NZ,SEARCH3	;not a match.
0716   DF41 13          	INC	DE
0717   DF42 23          	INC	HL
0718   DF43 05          	DEC	B
0719   DF44 C2 3C DF    	JP	NZ,SEARCH2
0720   DF47 1A          	LD	A,(DE)		;allow a 3 character command to match.
0721   DF48 FE 20       	CP	' '
0722   DF4A C2 54 DF    	JP	NZ,SEARCH4
0723   DF4D 79          	LD	A,C		;set return register for this command.
0724   DF4E C9          	RET	
0725   DF4F             SEARCH3:
0726   DF4F 23          	INC	HL
0727   DF50 05          	DEC	B
0728   DF51 C2 4F DF    	JP	NZ,SEARCH3
0729   DF54             SEARCH4:
0730   DF54 0C          	INC	C
0731   DF55 C3 33 DF    	JP	SEARCH1
0732   DF58             ;
0733   DF58             ;-------------------------------------------------------------
0734   DF58             ;   Set the input buffer to empty and then start the command
0735   DF58             ; processor (ccp).
0736   DF58             ;
0737   DF58             CLEARBUF:
0738   DF58 AF          	 XOR	A
0739   DF59 32 07 DC    	LD	(INBUFF+1),A	;second byte is actual length.
0740   DF5C             ;
0741   DF5C             ;-------------------------------------------------------------
0742   DF5C             ; C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0743   DF5C             ;
0744   DF5C             COMMAND:
0745   DF5C 31 AB E3    	LD	SP,CCPSTACK	;setup stack area.
0746   DF5F C5          	PUSH	BC		;note that (C) should be equal to:
0747   DF60             	
0748   DF60 79          	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
0749   DF61 1F          	RRA			;and 'dddd' is the drive number.
0750   DF62 1F          	RRA	
0751   DF63 1F          	RRA	
0752   DF64 1F          	RRA	
0753   DF65 E6 0F       	AND	0FH		;isolate the user number.
0754   DF67 5F          	LD	E,A
0755   DF68 CD 15 DD    	CALL	GETSETUC	;and set it.
0756   DF6B CD B8 DC    	CALL	RESDSK		;reset the disk system.
0757   DF6E 32 AB E3    	LD	(BATCH),A	;clear batch mode flag.
0758   DF71 C1          	POP	BC
TASM Z80 Assembler.               cpm22.z80                        page 14
CP/M Ver 2.2 CCP

0759   DF72 79          	LD	A,C
0760   DF73 E6 0F       	AND	0FH		;isolate the drive number.
0761   DF75 32 EF E3    	LD	(CDRIVE),A	;and save.
0762   DF78 CD BD DC    	CALL	DSKSEL		;...and select.
0763   DF7B 3A 07 DC    	LD	A,(INBUFF+1)
0764   DF7E B7          	OR	A		;anything in input buffer already?
0765   DF7F C2 98 DF    	JP	NZ,CMMND2	;yes, we just process it.
0766   DF82             ;
0767   DF82             ;   Entry point to get a command line from the console.
0768   DF82             ;
0769   DF82             CMMND1:
0770   DF82 31 AB E3    	LD	SP,CCPSTACK	;set stack straight.
0771   DF85 CD 98 DC    	CALL	CRLF		;start a new line on the screen.
0772   DF88 CD D0 DD    	CALL	GETDSK		;get current drive.
0773   DF8B C6 41       	ADD	A,'A'
0774   DF8D CD 8C DC    	CALL	PRINT		;print current drive.
0775   DF90 3E 3E       	LD	A,'>'
0776   DF92 CD 8C DC    	CALL	PRINT		;and add prompt.
0777   DF95 CD 39 DD    	CALL	GETINP		;get line from user.
0778   DF98             ;
0779   DF98             ;   Process command line here.
0780   DF98             ;
0781   DF98             CMMND2:
0782   DF98 11 80 00    	LD	DE,TBUFF
0783   DF9B CD D8 DD    	CALL	DMASET		;set standard dma address.
0784   DF9E CD D0 DD    	CALL	GETDSK
0785   DFA1 32 EF E3    	LD	(CDRIVE),A	;set current drive.
0786   DFA4 CD 5E DE    	CALL	CONVFST		;convert name typed in.
0787   DFA7 C4 09 DE    	CALL	NZ,SYNERR	;wild cards are not allowed.
0788   DFAA 3A F0 E3    	LD	A,(CHGDRV)	;if a change in drives was indicated,
0789   DFAD B7          	OR	A		;then treat this as an unknown command
0790   DFAE C2 A5 E2    	JP	NZ,UNKNOWN	;which gets executed.
0791   DFB1 CD 2E DF    	CALL	SEARCH		;else search command table for a match.
0792   DFB4             ;
0793   DFB4             ;   Note that an unknown command returns
0794   DFB4             ; with (A) pointing to the last address
0795   DFB4             ; in our table which is (UNKNOWN).
0796   DFB4             ;
0797   DFB4 21 C1 DF    	LD	HL,CMDADR	;now, look thru our address table for command (A).
0798   DFB7 5F          	LD	E,A		;set (DE) to command number.
0799   DFB8 16 00       	LD	D,0
0800   DFBA 19          	ADD	HL,DE
0801   DFBB 19          	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
0802   DFBC 7E          	LD	A,(HL)		;now pick out this address.
0803   DFBD 23          	INC	HL
0804   DFBE 66          	LD	H,(HL)
0805   DFBF 6F          	LD	L,A
0806   DFC0 E9          	JP	(HL)		;now execute it.
0807   DFC1             ;
0808   DFC1             ;-------------------------------------------------------------
0809   DFC1             ;   CP/M command address table.
0810   DFC1             ;
0811   DFC1             CMDADR:
0812   DFC1 77 E0 1F E1 	.WORD	DIRECT,ERASE,TYPE,SAVE
0812   DFC5 5D E1 AD E1 
0813   DFC9 10 E2 8E E2 	.WORD	RENAME,USER,UNKNOWN
0813   DFCD A5 E2 
0814   DFCF             ;
0815   DFCF             ;-------------------------------------------------------------
TASM Z80 Assembler.               cpm22.z80                        page 15
CP/M Ver 2.2 CCP

0816   DFCF             ;   Halt the system. This is done if the CCP
0817   DFCF             ; and BDOS serial numbers don't match
0818   DFCF             ;
0819   DFCF             HALT:
0820   DFCF 21 F3 76    	LD	HL,76F3H	;'DI HLT' instructions.
0821   DFD2 22 00 DC    	LD	(CBASE),HL
0822   DFD5 21 00 DC    	LD	HL,CBASE
0823   DFD8 E9          	JP	(HL)
0824   DFD9             ;
0825   DFD9             ;-------------------------------------------------------------
0826   DFD9             ;   Read error while TYPEing a file.
0827   DFD9             ;
0828   DFD9             RDERROR:
0829   DFD9 01 DF DF    	LD	BC,RDERR
0830   DFDC C3 A7 DC    	JP	PLINE
0831   DFDF             RDERR:
0832   DFDF 52 65 61 64 	.BYTE	"Read error",0
0832   DFE3 20 65 72 72 
0832   DFE7 6F 72 00 
0833   DFEA             ;
0834   DFEA             ;-------------------------------------------------------------
0835   DFEA             ;   Required file was not located.
0836   DFEA             ;
0837   DFEA             NONE:
0838   DFEA 01 F0 DF    	LD	BC,NOFILE
0839   DFED C3 A7 DC    	JP	PLINE
0840   DFF0             NOFILE:
0841   DFF0 4E 6F 20 66 	.BYTE	"No file",0
0841   DFF4 69 6C 65 00 
0842   DFF8             ;
0843   DFF8             ;-------------------------------------------------------------
0844   DFF8             ;   Decode a command of the form 'A>filename number{ filename}.
0845   DFF8             ; Note that a drive specifier is not allowed on the first file
0846   DFF8             ; name. On return, the number is in register (A). Any error
0847   DFF8             ; causes 'filename?' to be printed and the command is aborted.
0848   DFF8             ;
0849   DFF8             DECODE:
0850   DFF8 CD 5E DE    	CALL	CONVFST		;convert filename.
0851   DFFB 3A F0 E3    	LD	A,(CHGDRV)	;do not allow a drive to be specified.
0852   DFFE B7          	OR	A
0853   DFFF C2 09 DE    	JP	NZ,SYNERR
0854   E002 21 CE E3    	LD	HL,FCB+1	;convert number now.
0855   E005 01 0B 00    	LD	BC,11		;(B)=sum register, (C)=max digit count.
0856   E008             DECODE1:
0857   E008 7E          	LD	A,(HL)
0858   E009 FE 20       	CP	' '		;a space terminates the numeral.
0859   E00B CA 33 E0    	JP	Z,DECODE3
0860   E00E 23          	INC	HL
0861   E00F D6 30       	SUB	'0'		;make binary from ascii.
0862   E011 FE 0A       	CP	10		;legal digit?
0863   E013 D2 09 DE    	JP	NC,SYNERR
0864   E016 57          	LD	D,A		;yes, save it in (D).
0865   E017 78          	LD	A,B		;compute (B)=(B)*10 and check for overflow.
0866   E018 E6 E0       	AND	0E0H
0867   E01A C2 09 DE    	JP	NZ,SYNERR
0868   E01D 78          	LD	A,B
0869   E01E 07          	RLCA	
0870   E01F 07          	RLCA	
0871   E020 07          	RLCA			;(A)=(B)*8
TASM Z80 Assembler.               cpm22.z80                        page 16
CP/M Ver 2.2 CCP

0872   E021 80          	ADD	A,B		;.......*9
0873   E022 DA 09 DE    	JP	C,SYNERR
0874   E025 80          	ADD	A,B		;.......*10
0875   E026 DA 09 DE    	JP	C,SYNERR
0876   E029 82          	ADD	A,D		;add in new digit now.
0877   E02A             DECODE2:
0878   E02A DA 09 DE    	JP	C,SYNERR
0879   E02D 47          	LD	B,A		;and save result.
0880   E02E 0D          	DEC	C		;only look at 11 digits.
0881   E02F C2 08 E0    	JP	NZ,DECODE1
0882   E032 C9          	RET	
0883   E033             DECODE3:
0884   E033 7E          	LD	A,(HL)		;spaces must follow (why?).
0885   E034 FE 20       	CP	' '
0886   E036 C2 09 DE    	JP	NZ,SYNERR
0887   E039 23          	INC	HL
0888   E03A             DECODE4:
0889   E03A 0D          	DEC	C
0890   E03B C2 33 E0    	JP	NZ,DECODE3
0891   E03E 78          	LD	A,B		;set (A)=the numeric value entered.
0892   E03F C9          	RET	
0893   E040             ;
0894   E040             ;-------------------------------------------------------------
0895   E040             ;   Move 3 bytes from (HL) to (DE). Note that there is only
0896   E040             ; one reference to this near UNKWN2:.
0897   E040             ;
0898   E040             MOVE3:
0899   E040 06 03       	LD	B,3
0900   E042             ;
0901   E042             ;-------------------------------------------------------------
0902   E042             ;   Move (B) bytes from (HL) to (DE).
0903   E042             ;
0904   E042             HL2DE:
0905   E042 7E          	LD	A,(HL)
0906   E043 12          	LD	(DE),A
0907   E044 23          	INC	HL
0908   E045 13          	INC	DE
0909   E046 05          	DEC	B
0910   E047 C2 42 E0    	JP	NZ,HL2DE
0911   E04A C9          	RET	
0912   E04B             ;
0913   E04B             ;-------------------------------------------------------------
0914   E04B             ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0915   E04B             ;
0916   E04B             EXTRACT:
0917   E04B 21 80 00    	LD	HL,TBUFF
0918   E04E 81          	ADD	A,C
0919   E04F CD 59 DE    	CALL	ADDHL
0920   E052 7E          	LD	A,(HL)
0921   E053 C9          	RET	
0922   E054             ;
0923   E054             ;-------------------------------------------------------------
0924   E054             ;  Check drive specified. If it means a change, then the new
0925   E054             ; drive will be selected. In any case, the drive byte of the
0926   E054             ; fcb will be set to null (means use current drive).
0927   E054             ;
0928   E054             DSELECT:
0929   E054 AF          	XOR	A		;null out first byte of fcb.
0930   E055 32 CD E3    	LD	(FCB),A
TASM Z80 Assembler.               cpm22.z80                        page 17
CP/M Ver 2.2 CCP

0931   E058 3A F0 E3    	LD	A,(CHGDRV)	;a drive change indicated?
0932   E05B B7          	OR	A
0933   E05C C8          	RET	Z
0934   E05D 3D          	DEC	A		;yes, is it the same as the current drive?
0935   E05E 21 EF E3    	LD	HL,CDRIVE
0936   E061 BE          	CP	(HL)
0937   E062 C8          	RET	Z
0938   E063 C3 BD DC    	JP	DSKSEL		;no. Select it then.
0939   E066             ;
0940   E066             ;-------------------------------------------------------------
0941   E066             ;   Check the drive selection and reset it to the previous
0942   E066             ; drive if it was changed for the preceeding command.
0943   E066             ;
0944   E066             RESETDR:
0945   E066 3A F0 E3    	LD	A,(CHGDRV)	;drive change indicated?
0946   E069 B7          	OR	A
0947   E06A C8          	RET	Z
0948   E06B 3D          	DEC	A		;yes, was it a different drive?
0949   E06C 21 EF E3    	LD	HL,CDRIVE
0950   E06F BE          	CP	(HL)
0951   E070 C8          	RET	Z
0952   E071 3A EF E3    	LD	A,(CDRIVE)	;yes, re-select our old drive.
0953   E074 C3 BD DC    	JP	DSKSEL
0954   E077             ;
0955   E077             ;**************************************************************
0956   E077             ;*
0957   E077             ;*           D I R E C T O R Y   C O M M A N D
0958   E077             ;*
0959   E077             ;**************************************************************
0960   E077             ;
0961   E077             DIRECT:
0962   E077 CD 5E DE    	CALL	CONVFST		;convert file name.
0963   E07A CD 54 E0    	CALL	DSELECT		;select indicated drive.
0964   E07D 21 CE E3    	LD	HL,FCB+1	;was any file indicated?
0965   E080 7E          	LD	A,(HL)
0966   E081 FE 20       	CP	' '
0967   E083 C2 8F E0    	JP	NZ,DIRECT2
0968   E086 06 0B       	LD	B,11		;no. Fill field with '?' - same as *.*.
0969   E088             DIRECT1:
0970   E088 36 3F       	LD	(HL),'?'
0971   E08A 23          	INC	HL
0972   E08B 05          	DEC	B
0973   E08C C2 88 E0    	JP	NZ,DIRECT1
0974   E08F             DIRECT2:
0975   E08F 1E 00       	LD	E,0		;set initial cursor position.
0976   E091 D5          	PUSH	DE
0977   E092 CD E9 DC    	CALL	SRCHFCB		;get first file name.
0978   E095 CC EA DF    	CALL	Z,NONE		;none found at all?
0979   E098             DIRECT3:
0980   E098 CA 1B E1    	JP	Z,DIRECT9	;terminate if no more names.
0981   E09B 3A EE E3    	LD	A,(RTNCODE)	;get file's position in segment (0-3).
0982   E09E 0F          	RRCA	
0983   E09F 0F          	RRCA	
0984   E0A0 0F          	RRCA	
0985   E0A1 E6 60       	AND	60H		;(A)=position*32
0986   E0A3 4F          	LD	C,A
0987   E0A4 3E 0A       	LD	A,10
0988   E0A6 CD 4B E0    	CALL	EXTRACT		;extract the tenth entry in fcb.
0989   E0A9 17          	RLA			;check system file status bit.
TASM Z80 Assembler.               cpm22.z80                        page 18
CP/M Ver 2.2 CCP

0990   E0AA DA 0F E1    	JP	C,DIRECT8	;we don't list them.
0991   E0AD D1          	POP	DE
0992   E0AE 7B          	LD	A,E		;bump name count.
0993   E0AF 1C          	INC	E
0994   E0B0 D5          	PUSH	DE
0995   E0B1 E6 03       	AND	03H		;at end of line?
0996   E0B3 F5          	PUSH	AF
0997   E0B4 C2 CC E0    	JP	NZ,DIRECT4
0998   E0B7 CD 98 DC    	CALL	CRLF		;yes, end this line and start another.
0999   E0BA C5          	PUSH	BC
1000   E0BB CD D0 DD    	CALL	GETDSK		;start line with ('A:').
1001   E0BE C1          	POP	BC
1002   E0BF C6 41       	ADD	A,'A'
1003   E0C1 CD 92 DC    	CALL	PRINTB
1004   E0C4 3E 3A       	LD	A,':'
1005   E0C6 CD 92 DC    	CALL	PRINTB
1006   E0C9 C3 D4 E0    	JP	DIRECT5
1007   E0CC             DIRECT4:
1008   E0CC CD A2 DC    	CALL	SPACE		;add seperator between file names.
1009   E0CF 3E 3A       	LD	A,':'
1010   E0D1 CD 92 DC    	CALL	PRINTB
1011   E0D4             DIRECT5:
1012   E0D4 CD A2 DC    	CALL	SPACE
1013   E0D7 06 01       	LD	B,1		;'extract' each file name character at a time.
1014   E0D9             DIRECT6:
1015   E0D9 78          	LD	A,B
1016   E0DA CD 4B E0    	CALL	EXTRACT
1017   E0DD E6 7F       	AND	7FH		;strip bit 7 (status bit).
1018   E0DF FE 20       	CP	' '		;are we at the end of the name?
1019   E0E1 C2 F9 E0    	JP	NZ,DRECT65
1020   E0E4 F1          	POP	AF		;yes, don't print spaces at the end of a line.
1021   E0E5 F5          	PUSH	AF
1022   E0E6 FE 03       	CP	3
1023   E0E8 C2 F7 E0    	JP	NZ,DRECT63
1024   E0EB 3E 09       	LD	A,9		;first check for no extension.
1025   E0ED CD 4B E0    	CALL	EXTRACT
1026   E0F0 E6 7F       	AND	7FH
1027   E0F2 FE 20       	CP	' '
1028   E0F4 CA 0E E1    	JP	Z,DIRECT7	;don't print spaces.
1029   E0F7             DRECT63:
1030   E0F7 3E 20       	LD	A,' '		;else print them.
1031   E0F9             DRECT65:
1032   E0F9 CD 92 DC    	CALL	PRINTB
1033   E0FC 04          	INC	B		;bump to next character psoition.
1034   E0FD 78          	LD	A,B
1035   E0FE FE 0C       	CP	12		;end of the name?
1036   E100 D2 0E E1    	JP	NC,DIRECT7
1037   E103 FE 09       	CP	9		;nope, starting extension?
1038   E105 C2 D9 E0    	JP	NZ,DIRECT6
1039   E108 CD A2 DC    	CALL	SPACE		;yes, add seperating space.
1040   E10B C3 D9 E0    	JP	DIRECT6
1041   E10E             DIRECT7:
1042   E10E F1          	POP	AF		;get the next file name.
1043   E10F             DIRECT8:
1044   E10F CD C2 DD    	CALL	CHKCON		;first check console, quit on anything.
1045   E112 C2 1B E1    	JP	NZ,DIRECT9
1046   E115 CD E4 DC    	CALL	SRCHNXT		;get next name.
1047   E118 C3 98 E0    	JP	DIRECT3		;and continue with our list.
1048   E11B             DIRECT9:
TASM Z80 Assembler.               cpm22.z80                        page 19
CP/M Ver 2.2 CCP

1049   E11B D1          	POP	DE		;restore the stack and return to command level.
1050   E11C C3 86 E3    	JP	GETBACK
1051   E11F             ;
1052   E11F             ;**************************************************************
1053   E11F             ;*
1054   E11F             ;*                E R A S E   C O M M A N D
1055   E11F             ;*
1056   E11F             ;**************************************************************
1057   E11F             ;
1058   E11F             ERASE:
1059   E11F CD 5E DE    	CALL	CONVFST		;convert file name.
1060   E122 FE 0B       	CP	11		;was '*.*' entered?
1061   E124 C2 42 E1    	JP	NZ,ERASE1
1062   E127 01 52 E1    	LD	BC,YESNO	;yes, ask for confirmation.
1063   E12A CD A7 DC    	CALL	PLINE
1064   E12D CD 39 DD    	CALL	GETINP
1065   E130 21 07 DC    	LD	HL,INBUFF+1
1066   E133 35          	DEC	(HL)		;must be exactly 'y'.
1067   E134 C2 82 DF    	JP	NZ,CMMND1
1068   E137 23          	INC	HL
1069   E138 7E          	LD	A,(HL)
1070   E139 FE 59       	CP	'Y'
1071   E13B C2 82 DF    	JP	NZ,CMMND1
1072   E13E 23          	INC	HL
1073   E13F 22 88 DC    	LD	(INPOINT),HL	;save input line pointer.
1074   E142             ERASE1:
1075   E142 CD 54 E0    	CALL	DSELECT		;select desired disk.
1076   E145 11 CD E3    	LD	DE,FCB
1077   E148 CD EF DC    	CALL	DELETE		;delete the file.
1078   E14B 3C          	INC	A
1079   E14C CC EA DF    	CALL	Z,NONE		;not there?
1080   E14F C3 86 E3    	JP	GETBACK		;return to command level now.
1081   E152             YESNO:
1082   E152 41 6C 6C 20 	.BYTE	"All (y/n)?",0
1082   E156 28 79 2F 6E 
1082   E15A 29 3F 00 
1083   E15D             ;
1084   E15D             ;**************************************************************
1085   E15D             ;*
1086   E15D             ;*            T Y P E   C O M M A N D
1087   E15D             ;*
1088   E15D             ;**************************************************************
1089   E15D             ;
1090   E15D             TYPE:
1091   E15D CD 5E DE    	CALL	CONVFST		;convert file name.
1092   E160 C2 09 DE    	JP	NZ,SYNERR	;wild cards not allowed.
1093   E163 CD 54 E0    	CALL	DSELECT		;select indicated drive.
1094   E166 CD D0 DC    	CALL	OPENFCB		;open the file.
1095   E169 CA A7 E1    	JP	Z,TYPE5		;not there?
1096   E16C CD 98 DC    	CALL	CRLF		;ok, start a new line on the screen.
1097   E16F 21 F1 E3    	LD	HL,NBYTES	;initialize byte counter.
1098   E172 36 FF       	LD	(HL),0FFH	;set to read first sector.
1099   E174             TYPE1:
1100   E174 21 F1 E3    	LD	HL,NBYTES
1101   E177             TYPE2:
1102   E177 7E          	LD	A,(HL)		;have we written the entire sector?
1103   E178 FE 80       	CP	128
1104   E17A DA 87 E1    	JP	C,TYPE3
1105   E17D E5          	PUSH	HL		;yes, read in the next one.
TASM Z80 Assembler.               cpm22.z80                        page 20
CP/M Ver 2.2 CCP

1106   E17E CD FE DC    	CALL	READFCB
1107   E181 E1          	POP	HL
1108   E182 C2 A0 E1    	JP	NZ,TYPE4	;end or error?
1109   E185 AF          	XOR	A		;ok, clear byte counter.
1110   E186 77          	LD	(HL),A
1111   E187             TYPE3:
1112   E187 34          	INC	(HL)		;count this byte.
1113   E188 21 80 00    	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
1114   E18B CD 59 DE    	CALL	ADDHL
1115   E18E 7E          	LD	A,(HL)
1116   E18F FE 1A       	CP	CNTRLZ		;end of file mark?
1117   E191 CA 86 E3    	JP	Z,GETBACK
1118   E194 CD 8C DC    	CALL	PRINT		;no, print it.
1119   E197 CD C2 DD    	CALL	CHKCON		;check console, quit if anything ready.
1120   E19A C2 86 E3    	JP	NZ,GETBACK
1121   E19D C3 74 E1    	JP	TYPE1
1122   E1A0             ;
1123   E1A0             ;   Get here on an end of file or read error.
1124   E1A0             ;
1125   E1A0             TYPE4:
1126   E1A0 3D          	DEC	A		;read error?
1127   E1A1 CA 86 E3    	JP	Z,GETBACK
1128   E1A4 CD D9 DF    	CALL	RDERROR		;yes, print message.
1129   E1A7             TYPE5:
1130   E1A7 CD 66 E0    	CALL	RESETDR		;and reset proper drive
1131   E1AA C3 09 DE    	JP	SYNERR		;now print file name with problem.
1132   E1AD             ;
1133   E1AD             ;**************************************************************
1134   E1AD             ;*
1135   E1AD             ;*            S A V E   C O M M A N D
1136   E1AD             ;*
1137   E1AD             ;**************************************************************
1138   E1AD             ;
1139   E1AD             SAVE:
1140   E1AD CD F8 DF    	CALL	DECODE		;get numeric number that follows SAVE.
1141   E1B0 F5          	PUSH	AF		;save number of pages to write.
1142   E1B1 CD 5E DE    	CALL	CONVFST		;convert file name.
1143   E1B4 C2 09 DE    	JP	NZ,SYNERR	;wild cards not allowed.
1144   E1B7 CD 54 E0    	CALL	DSELECT		;select specified drive.
1145   E1BA 11 CD E3    	LD	DE,FCB		;now delete this file.
1146   E1BD D5          	PUSH	DE
1147   E1BE CD EF DC    	CALL	DELETE
1148   E1C1 D1          	POP	DE
1149   E1C2 CD 09 DD    	CALL	CREATE		;and create it again.
1150   E1C5 CA FB E1    	JP	Z,SAVE3		;can't create?
1151   E1C8 AF          	XOR	A		;clear record number byte.
1152   E1C9 32 ED E3    	LD	(FCB+32),A
1153   E1CC F1          	POP	AF		;convert pages to sectors.
1154   E1CD 6F          	LD	L,A
1155   E1CE 26 00       	LD	H,0
1156   E1D0 29          	ADD	HL,HL		;(HL)=number of sectors to write.
1157   E1D1 11 00 01    	LD	DE,TBASE	;and we start from here.
1158   E1D4             SAVE1:
1159   E1D4 7C          	LD	A,H		;done yet?
1160   E1D5 B5          	OR	L
1161   E1D6 CA F1 E1    	JP	Z,SAVE2
1162   E1D9 2B          	DEC	HL		;nope, count this and compute the start
1163   E1DA E5          	PUSH	HL		;of the next 128 byte sector.
1164   E1DB 21 80 00    	LD	HL,128
TASM Z80 Assembler.               cpm22.z80                        page 21
CP/M Ver 2.2 CCP

1165   E1DE 19          	ADD	HL,DE
1166   E1DF E5          	PUSH	HL		;save it and set the transfer address.
1167   E1E0 CD D8 DD    	CALL	DMASET
1168   E1E3 11 CD E3    	LD	DE,FCB		;write out this sector now.
1169   E1E6 CD 04 DD    	CALL	WRTREC
1170   E1E9 D1          	POP	DE		;reset (DE) to the start of the last sector.
1171   E1EA E1          	POP	HL		;restore sector count.
1172   E1EB C2 FB E1    	JP	NZ,SAVE3	;write error?
1173   E1EE C3 D4 E1    	JP	SAVE1
1174   E1F1             ;
1175   E1F1             ;   Get here after writing all of the file.
1176   E1F1             ;
1177   E1F1             SAVE2:
1178   E1F1 11 CD E3    	LD	DE,FCB		;now close the file.
1179   E1F4 CD DA DC    	CALL	CLOSE
1180   E1F7 3C          	INC	A		;did it close ok?
1181   E1F8 C2 01 E2    	JP	NZ,SAVE4
1182   E1FB             ;
1183   E1FB             ;   Print out error message (no space).
1184   E1FB             ;
1185   E1FB             SAVE3:
1186   E1FB 01 07 E2    	LD	BC,NOSPACE
1187   E1FE CD A7 DC    	CALL	PLINE
1188   E201             SAVE4:
1189   E201 CD D5 DD    	CALL	STDDMA		;reset the standard dma address.
1190   E204 C3 86 E3    	JP	GETBACK
1191   E207             NOSPACE:
1192   E207 4E 6F 20 73 	.BYTE	"No space",0
1192   E20B 70 61 63 65 
1192   E20F 00 
1193   E210             ;
1194   E210             ;**************************************************************
1195   E210             ;*
1196   E210             ;*           R E N A M E   C O M M A N D
1197   E210             ;*
1198   E210             ;**************************************************************
1199   E210             ;
1200   E210             RENAME:
1201   E210 CD 5E DE    	CALL	CONVFST		;convert first file name.
1202   E213 C2 09 DE    	JP	NZ,SYNERR	;wild cards not allowed.
1203   E216 3A F0 E3    	LD	A,(CHGDRV)	;remember any change in drives specified.
1204   E219 F5          	PUSH	AF
1205   E21A CD 54 E0    	CALL	DSELECT		;and select this drive.
1206   E21D CD E9 DC    	CALL	SRCHFCB		;is this file present?
1207   E220 C2 79 E2    	JP	NZ,RENAME6	;yes, print error message.
1208   E223 21 CD E3    	LD	HL,FCB		;yes, move this name into second slot.
1209   E226 11 DD E3    	LD	DE,FCB+16
1210   E229 06 10       	LD	B,16
1211   E22B CD 42 E0    	CALL	HL2DE
1212   E22E 2A 88 DC    	LD	HL,(INPOINT)	;get input pointer.
1213   E231 EB          	EX	DE,HL
1214   E232 CD 4F DE    	CALL	NONBLANK	;get next non blank character.
1215   E235 FE 3D       	CP	'='		;only allow an '=' or '_' seperator.
1216   E237 CA 3F E2    	JP	Z,RENAME1
1217   E23A FE 5F       	CP	'_'
1218   E23C C2 73 E2    	JP	NZ,RENAME5
1219   E23F             RENAME1:
1220   E23F EB          	EX	DE,HL
1221   E240 23          	INC	HL		;ok, skip seperator.
TASM Z80 Assembler.               cpm22.z80                        page 22
CP/M Ver 2.2 CCP

1222   E241 22 88 DC    	LD	(INPOINT),HL	;save input line pointer.
1223   E244 CD 5E DE    	CALL	CONVFST		;convert this second file name now.
1224   E247 C2 73 E2    	JP	NZ,RENAME5	;again, no wild cards.
1225   E24A F1          	POP	AF		;if a drive was specified, then it
1226   E24B 47          	LD	B,A		;must be the same as before.
1227   E24C 21 F0 E3    	LD	HL,CHGDRV
1228   E24F 7E          	LD	A,(HL)
1229   E250 B7          	OR	A
1230   E251 CA 59 E2    	JP	Z,RENAME2
1231   E254 B8          	CP	B
1232   E255 70          	LD	(HL),B
1233   E256 C2 73 E2    	JP	NZ,RENAME5	;they were different, error.
1234   E259             RENAME2:
1235   E259 70          	LD	(HL),B		;reset as per the first file specification.
1236   E25A AF          	XOR	A
1237   E25B 32 CD E3    	LD	(FCB),A		;clear the drive byte of the fcb.
1238   E25E             RENAME3:
1239   E25E CD E9 DC    	CALL	SRCHFCB		;and go look for second file.
1240   E261 CA 6D E2    	JP	Z,RENAME4	;doesn't exist?
1241   E264 11 CD E3    	LD	DE,FCB
1242   E267 CD 0E DD    	CALL	RENAM		;ok, rename the file.
1243   E26A C3 86 E3    	JP	GETBACK
1244   E26D             ;
1245   E26D             ;   Process rename errors here.
1246   E26D             ;
1247   E26D             RENAME4:
1248   E26D CD EA DF    	CALL	NONE		;file not there.
1249   E270 C3 86 E3    	JP	GETBACK
1250   E273             RENAME5:
1251   E273 CD 66 E0    	CALL	RESETDR		;bad command format.
1252   E276 C3 09 DE    	JP	SYNERR
1253   E279             RENAME6:
1254   E279 01 82 E2    	LD	BC,EXISTS	;destination file already exists.
1255   E27C CD A7 DC    	CALL	PLINE
1256   E27F C3 86 E3    	JP	GETBACK
1257   E282             EXISTS:
1258   E282 46 69 6C 65 	.BYTE	"File exists",0
1258   E286 20 65 78 69 
1258   E28A 73 74 73 00 
1259   E28E             ;
1260   E28E             ;**************************************************************
1261   E28E             ;*
1262   E28E             ;*             U S E R   C O M M A N D
1263   E28E             ;*
1264   E28E             ;**************************************************************
1265   E28E             ;
1266   E28E             USER:
1267   E28E CD F8 DF    	CALL	DECODE		;get numeric value following command.
1268   E291 FE 10       	CP	16		;legal user number?
1269   E293 D2 09 DE    	JP	NC,SYNERR
1270   E296 5F          	LD	E,A		;yes but is there anything else?
1271   E297 3A CE E3    	LD	A,(FCB+1)
1272   E29A FE 20       	CP	' '
1273   E29C CA 09 DE    	JP	Z,SYNERR	;yes, that is not allowed.
1274   E29F CD 15 DD    	CALL	GETSETUC	;ok, set user code.
1275   E2A2 C3 89 E3    	JP	GETBACK1
1276   E2A5             ;
1277   E2A5             ;**************************************************************
1278   E2A5             ;*
TASM Z80 Assembler.               cpm22.z80                        page 23
CP/M Ver 2.2 CCP

1279   E2A5             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1280   E2A5             ;*
1281   E2A5             ;**************************************************************
1282   E2A5             ;
1283   E2A5             UNKNOWN:
1284   E2A5 CD F5 DD    	CALL	VERIFY		;check for valid system.
1285   E2A8 3A CE E3    	LD	A,(FCB+1)	;anything to execute?
1286   E2AB FE 20       	CP	' '
1287   E2AD C2 C4 E2    	JP	NZ,UNKWN1
1288   E2B0 3A F0 E3    	LD	A,(CHGDRV)	;nope, only a drive change?
1289   E2B3 B7          	OR	A
1290   E2B4 CA 89 E3    	JP	Z,GETBACK1	;neither???
1291   E2B7 3D          	DEC	A
1292   E2B8 32 EF E3    	LD	(CDRIVE),A	;ok, store new drive.
1293   E2BB CD 29 DD    	CALL	MOVECD		;set (TDRIVE) also.
1294   E2BE CD BD DC    	CALL	DSKSEL		;and select this drive.
1295   E2C1 C3 89 E3    	JP	GETBACK1	;then return.
1296   E2C4             ;
1297   E2C4             ;   Here a file name was typed. Prepare to execute it.
1298   E2C4             ;
1299   E2C4             UNKWN1:
1300   E2C4 11 D6 E3    	LD	DE,FCB+9	;an extension specified?
1301   E2C7 1A          	LD	A,(DE)
1302   E2C8 FE 20       	CP	' '
1303   E2CA C2 09 DE    	JP	NZ,SYNERR	;yes, not allowed.
1304   E2CD             UNKWN2:
1305   E2CD D5          	PUSH	DE
1306   E2CE CD 54 E0    	CALL	DSELECT		;select specified drive.
1307   E2D1 D1          	POP	DE
1308   E2D2 21 83 E3    	LD	HL,COMFILE	;set the extension to 'COM'.
1309   E2D5 CD 40 E0    	CALL	MOVE3
1310   E2D8 CD D0 DC    	CALL	OPENFCB		;and open this file.
1311   E2DB CA 6B E3    	JP	Z,UNKWN9	;not present?
1312   E2DE             ;
1313   E2DE             ;   Load in the program.
1314   E2DE             ;
1315   E2DE 21 00 01    	LD	HL,TBASE	;store the program starting here.
1316   E2E1             UNKWN3:
1317   E2E1 E5          	PUSH	HL
1318   E2E2 EB          	EX	DE,HL
1319   E2E3 CD D8 DD    	CALL	DMASET		;set transfer address.
1320   E2E6 11 CD E3    	LD	DE,FCB		;and read the next record.
1321   E2E9 CD F9 DC    	CALL	RDREC
1322   E2EC C2 01 E3    	JP	NZ,UNKWN4	;end of file or read error?
1323   E2EF E1          	POP	HL		;nope, bump pointer for next sector.
1324   E2F0 11 80 00    	LD	DE,128
1325   E2F3 19          	ADD	HL,DE
1326   E2F4 11 00 DC    	LD	DE,CBASE	;enough room for the whole file?
1327   E2F7 7D          	LD	A,L
1328   E2F8 93          	SUB	E
1329   E2F9 7C          	LD	A,H
1330   E2FA 9A          	SBC	A,D
1331   E2FB D2 71 E3    	JP	NC,UNKWN0	;no, it can't fit.
1332   E2FE C3 E1 E2    	JP	UNKWN3
1333   E301             ;
1334   E301             ;   Get here after finished reading.
1335   E301             ;
1336   E301             UNKWN4:
1337   E301 E1          	POP	HL
TASM Z80 Assembler.               cpm22.z80                        page 24
CP/M Ver 2.2 CCP

1338   E302 3D          	DEC	A		;normal end of file?
1339   E303 C2 71 E3    	JP	NZ,UNKWN0
1340   E306 CD 66 E0    	CALL	RESETDR		;yes, reset previous drive.
1341   E309 CD 5E DE    	CALL	CONVFST		;convert the first file name that follows
1342   E30C 21 F0 E3    	LD	HL,CHGDRV	;command name.
1343   E30F E5          	PUSH	HL
1344   E310 7E          	LD	A,(HL)		;set drive code in default fcb.
1345   E311 32 CD E3    	LD	(FCB),A
1346   E314 3E 10       	LD	A,16		;put second name 16 bytes later.
1347   E316 CD 60 DE    	CALL	CONVERT		;convert second file name.
1348   E319 E1          	POP	HL
1349   E31A 7E          	LD	A,(HL)		;and set the drive for this second file.
1350   E31B 32 DD E3    	LD	(FCB+16),A
1351   E31E AF          	XOR	A		;clear record byte in fcb.
1352   E31F 32 ED E3    	LD	(FCB+32),A
1353   E322 11 5C 00    	LD	DE,TFCB		;move it into place at(005Ch).
1354   E325 21 CD E3    	LD	HL,FCB
1355   E328 06 21       	LD	B,33
1356   E32A CD 42 E0    	CALL	HL2DE
1357   E32D 21 08 DC    	LD	HL,INBUFF+2	;now move the remainder of the input
1358   E330             UNKWN5:
1359   E330 7E          	LD	A,(HL)		;line down to (0080h). Look for a non blank.
1360   E331 B7          	OR	A		;or a null.
1361   E332 CA 3E E3    	JP	Z,UNKWN6
1362   E335 FE 20       	CP	' '
1363   E337 CA 3E E3    	JP	Z,UNKWN6
1364   E33A 23          	INC	HL
1365   E33B C3 30 E3    	JP	UNKWN5
1366   E33E             ;
1367   E33E             ;   Do the line move now. It ends in a null byte.
1368   E33E             ;
1369   E33E             UNKWN6:
1370   E33E 06 00       	LD	B,0		;keep a character count.
1371   E340 11 81 00    	LD	DE,TBUFF+1	;data gets put here.
1372   E343             UNKWN7:
1373   E343 7E          	LD	A,(HL)		;move it now.
1374   E344 12          	LD	(DE),A
1375   E345 B7          	OR	A
1376   E346 CA 4F E3    	JP	Z,UNKWN8
1377   E349 04          	INC	B
1378   E34A 23          	INC	HL
1379   E34B 13          	INC	DE
1380   E34C C3 43 E3    	JP	UNKWN7
1381   E34F             UNKWN8:
1382   E34F 78          	LD	A,B		;now store the character count.
1383   E350 32 80 00    	LD	(TBUFF),A
1384   E353 CD 98 DC    	CALL	CRLF		;clean up the screen.
1385   E356 CD D5 DD    	CALL	STDDMA		;set standard transfer address.
1386   E359 CD 1A DD    	CALL	SETCDRV		;reset current drive.
1387   E35C CD 00 01    	CALL	TBASE		;and execute the program.
1388   E35F             ;
1389   E35F             ;   Transiant programs return here (or reboot).
1390   E35F             ;
1391   E35F 31 AB E3    	LD	SP,BATCH	;set stack first off.
1392   E362 CD 29 DD    	CALL	MOVECD		;move current drive into place (TDRIVE).
1393   E365 CD BD DC    	CALL	DSKSEL		;and reselect it.
1394   E368 C3 82 DF    	JP	CMMND1		;back to comand mode.
1395   E36B             ;
1396   E36B             ;   Get here if some error occured.
TASM Z80 Assembler.               cpm22.z80                        page 25
CP/M Ver 2.2 CCP

1397   E36B             ;
1398   E36B             UNKWN9:
1399   E36B CD 66 E0    	CALL	RESETDR		;inproper format.
1400   E36E C3 09 DE    	JP	SYNERR
1401   E371             UNKWN0:
1402   E371 01 7A E3    	LD	BC,BADLOAD	;read error or won't fit.
1403   E374 CD A7 DC    	CALL	PLINE
1404   E377 C3 86 E3    	JP	GETBACK
1405   E37A             BADLOAD:
1406   E37A 42 61 64 20 	.BYTE	"Bad load",0
1406   E37E 6C 6F 61 64 
1406   E382 00 
1407   E383             COMFILE:
1408   E383 43 4F 4D    	.BYTE	"COM"		;command file extension.
1409   E386             ;
1410   E386             ;   Get here to return to command level. We will reset the
1411   E386             ; previous active drive and then either return to command
1412   E386             ; level directly or print error message and then return.
1413   E386             ;
1414   E386             GETBACK:
1415   E386 CD 66 E0    	CALL	RESETDR		;reset previous drive.
1416   E389             GETBACK1:
1417   E389 CD 5E DE    	CALL	CONVFST		;convert first name in (FCB).
1418   E38C 3A CE E3    	LD	A,(FCB+1)	;if this was just a drive change request,
1419   E38F D6 20       	SUB	' '		;make sure it was valid.
1420   E391 21 F0 E3    	LD	HL,CHGDRV
1421   E394 B6          	OR	(HL)
1422   E395 C2 09 DE    	JP	NZ,SYNERR
1423   E398 C3 82 DF    	JP	CMMND1		;ok, return to command level.
TASM Z80 Assembler.               cpm22.z80                        page 26
CP/M Ver 2.2 CCP

1424   E39B             	.eject
1425   E39B             ;
1426   E39B             ;-------------------------------------------------------------
1427   E39B             ;   ccp stack area.
1428   E39B             ;
1429   E39B 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
1429   E39F 00 00 00 00 
1430   E3A3 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
1430   E3A7 00 00 00 00 
1431   E3AB             ;
1432   E3AB             CCPSTACK .EQU	$	;end of ccp stack area.
1433   E3AB             ;
1434   E3AB             ;-------------------------------------------------------------
1435   E3AB             ;   Batch (or SUBMIT) processing information storage.
1436   E3AB             ;
1437   E3AB             BATCH:
1438   E3AB 00          	.BYTE	0	;batch mode flag (0=not active).
1439   E3AC             BATCHFCB:
1440   E3AC 00          	.BYTE	0
1441   E3AD 24 24 24 20 	.BYTE	"$$$     SUB"
1441   E3B1 20 20 20 20 
1441   E3B5 53 55 42 
1442   E3B8 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
1442   E3BC 00 00 00 00 
1443   E3C0 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
1443   E3C4 00 00 00 00 
1444   E3C8 00 00 00 00 	.BYTE	0,0,0,0,0
1444   E3CC 00 
1445   E3CD             ;
1446   E3CD             ;-------------------------------------------------------------
1447   E3CD             ;   File control block setup by the CCP.
1448   E3CD             ;
1449   E3CD             FCB:
1450   E3CD 00          	.BYTE	0
1451   E3CE 20 20 20 20 	.BYTE	"           "
1451   E3D2 20 20 20 20 
1451   E3D6 20 20 20 
1452   E3D9 00 00 00 00 	.BYTE	0,0,0,0,0
1452   E3DD 00 
1453   E3DE 20 20 20 20 	.BYTE	"           "
1453   E3E2 20 20 20 20 
1453   E3E6 20 20 20 
1454   E3E9 00 00 00 00 	.BYTE	0,0,0,0,0
1454   E3ED 00 
1455   E3EE             RTNCODE:
1456   E3EE 00          	.BYTE	0	;status returned from bdos call.
1457   E3EF             CDRIVE:
1458   E3EF 00          	.BYTE	0	;currently active drive.
1459   E3F0             CHGDRV:
1460   E3F0 00          	.BYTE	0	;change in drives flag (0=no change).
1461   E3F1             NBYTES:
1462   E3F1 00 00       	.WORD	0	;byte counter used by TYPE.
1463   E3F3             ;
1464   E3F3             ;-------------------------------------------------------------
1465   E3F3             ;   Room for expansion?
1466   E3F3             ;
1467   E3F3 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
1467   E3F7 00 00 00 00 
1468   E3FB 00 00 00 00 	.BYTE	0,0,0,0,0
TASM Z80 Assembler.               cpm22.z80                        page 27
CP/M Ver 2.2 CCP

1468   E3FF 00 
1469   E400             ;
TASM Z80 Assembler.               cpm22.z80                        page 28
CP/M Ver 2.2 CCP

1470   E400             	.EJECT
1471   E400             	.ORG CBASE+800h
1472   E400             	.TITLE " CP/M Ver 2.2 BDOS"
TASM Z80 Assembler.               cpm22.z80                        page 29
 CP/M Ver 2.2 BDOS

1473   E400             	.EJECT
1474   E400             ;**************************************************************
1475   E400             ; CP/M Version 2.2 Basic Disk Operating System
1476   E400             ;**************************************************************
1477   E400             ;
1478   E400             PATTRN2:
1479   E400 00 16 00 00 	.BYTE	0,22,0,0,0,0	;BDOS serial number bytes.
1479   E404 00 00 
1480   E406             ;
1481   E406             FBASE:
1482   E406 C3 11 E4    	JP	FBASE1		;BDOS entry point
1483   E409             ;
1484   E409             ;-------------------------------------------------------------
1485   E409             ;   Bdos error table.
1486   E409             ;
1487   E409             BADSCTR:
1488   E409 99 E4       	.WORD	ERROR1		;bad sector on read or write.
1489   E40B             BADSLCT:
1490   E40B A5 E4       	.WORD	ERROR2		;bad disk select.
1491   E40D             RODISK:
1492   E40D AB E4       	.WORD	ERROR3		;disk is read only.
1493   E40F             ROFILE:
1494   E40F B1 E4       	.WORD	ERROR4		;file is read only.
1495   E411             ;
TASM Z80 Assembler.               cpm22.z80                        page 30
 CP/M Ver 2.2 BDOS

1496   E411             	.eject
1497   E411             ;
1498   E411             ;-------------------------------------------------------------
1499   E411             ;   Entry into bdos. (DE) or (E) are the parameters passed. The
1500   E411             ; function number desired is in register (C).
1501   E411             ;
1502   E411             FBASE1:
1503   E411 EB          	EX	DE,HL		;save the (DE) parameters.
1504   E412 22 43 E7    	LD	(PARAMS),HL
1505   E415 EB          	EX	DE,HL
1506   E416 7B          	LD	A,E		;and save register (E) in particular.
1507   E417 32 D7 F1    	LD	(EPARAM),A
1508   E41A 21 00 00    	LD	HL,0
1509   E41D 22 45 E7    	LD	(STATUS),HL	;clear return status.
1510   E420 39          	ADD	HL,SP
1511   E421 22 0F E7    	LD	(USRSTACK),HL	;save users stack pointer.
1512   E424 31 41 E7    	LD	SP,STKAREA	;and set our own.
1513   E427 AF          	XOR	A		;clear auto select storage space.
1514   E428 32 E1 F1    	LD	(AUTOFLAG),A
1515   E42B 32 DF F1    	LD	(AUTO),A
1516   E42E 21 75 F1    	LD	HL,GOBACK	;set return address.
1517   E431 E5          	PUSH	HL
1518   E432 79          	LD	A,C		;get function number.
1519   E433 FE 29       	CP	NFUNCTS		;valid function number?
1520   E435 D0          	RET	NC
1521   E436 4B          	LD	C,E		;keep single register function here.
1522   E437 21 47 E4    	LD	HL,FUNCTNS	;now look thru the function table.
1523   E43A 5F          	LD	E,A
1524   E43B 16 00       	LD	D,0		;(DE)=function number.
1525   E43D 19          	ADD	HL,DE
1526   E43E 19          	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
1527   E43F 5E          	LD	E,(HL)
1528   E440 23          	INC	HL
1529   E441 56          	LD	D,(HL)		;now (DE)=address for this function.
1530   E442 2A 43 E7    	LD	HL,(PARAMS)	;retrieve parameters.
1531   E445 EB          	EX	DE,HL		;now (DE) has the original parameters.
1532   E446 E9          	JP	(HL)		;execute desired function.
1533   E447             ;
1534   E447             ;-------------------------------------------------------------
1535   E447             ;   BDOS function jump table.
1536   E447             ;
1537   E447             NFUNCTS .EQU	41		;number of functions in followin table.
1538   E447             ;
1539   E447             FUNCTNS:
1540   E447 03 F2 C8 E6 	.WORD	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1540   E44B 90 E5 CE E6 
1540   E44F 12 F2 0F F2 
1540   E453 D4 E6 ED E6 
1541   E457 F3 E6 F8 E6 	.WORD	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1541   E45B E1 E5 FE E6 
1541   E45F 7E F0 83 F0 
1541   E463 45 F0 9D F0 
1542   E467 A6 F0 AC F0 	.WORD	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1542   E46B C9 F0 D8 F0 
1542   E46F E1 F0 E7 F0 
1542   E473 ED F0 
1543   E475 F6 F0 FF F0 	.WORD	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1543   E479 05 F1 0B F1 
1543   E47D 12 F1 2C E9 
TASM Z80 Assembler.               cpm22.z80                        page 31
 CP/M Ver 2.2 BDOS

1543   E481 18 F1 1E F1 
1544   E485 27 F1 2E F1 	.WORD	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1544   E489 42 F1 48 F1 
1544   E48D 4E F1 0E F0 
1544   E491 54 F1 04 E7 
1545   E495 04 E7 9C F1 	.WORD	RTN,WTSPECL
1546   E499             ;
1547   E499             ;-------------------------------------------------------------
1548   E499             ;   Bdos error message section.
1549   E499             ;
1550   E499             ERROR1:
1551   E499 21 CA E4    	LD	HL,BADSEC	;bad sector message.
1552   E49C CD E5 E4    	CALL	PRTERR		;print it and get a 1 char responce.
1553   E49F FE 03       	CP	CNTRLC		;re-boot request (control-c)?
1554   E4A1 CA 00 00    	JP	Z,0		;yes.
1555   E4A4 C9          	RET			;no, return to retry i/o function.
1556   E4A5             ;
1557   E4A5             ERROR2:
1558   E4A5 21 D5 E4    	LD	HL,BADSEL	;bad drive selected.
1559   E4A8 C3 B4 E4    	JP	ERROR5
1560   E4AB             ;
1561   E4AB             ERROR3:
1562   E4AB 21 E1 E4    	LD	HL,DISKRO	;disk is read only.
1563   E4AE C3 B4 E4    	JP	ERROR5
1564   E4B1             ;
1565   E4B1             ERROR4:
1566   E4B1 21 DC E4    	LD	HL,FILERO	;file is read only.
1567   E4B4             ;
1568   E4B4             ERROR5:
1569   E4B4 CD E5 E4    	CALL	PRTERR
1570   E4B7 C3 00 00    	JP	0		;always reboot on these errors.
1571   E4BA             ;
1572   E4BA             BDOSERR:
1573   E4BA 42 64 6F 73 	.BYTE	"Bdos Err On "
1573   E4BE 20 45 72 72 
1573   E4C2 20 4F 6E 20 
1574   E4C6             BDOSDRV:
1575   E4C6 20 3A 20 24 	.BYTE	" : $"
1576   E4CA             BADSEC:
1577   E4CA 42 61 64 20 	.BYTE	"Bad Sector$"
1577   E4CE 53 65 63 74 
1577   E4D2 6F 72 24 
1578   E4D5             BADSEL:
1579   E4D5 53 65 6C 65 	.BYTE	"Select$"
1579   E4D9 63 74 24 
1580   E4DC             FILERO:
1581   E4DC 46 69 6C 65 	.BYTE	"File "
1581   E4E0 20 
1582   E4E1             DISKRO:
1583   E4E1 52 2F 4F 24 	.BYTE	"R/O$"
1584   E4E5             ;
1585   E4E5             ;-------------------------------------------------------------
1586   E4E5             ;   Print bdos error message.
1587   E4E5             ;
1588   E4E5             PRTERR:
1589   E4E5 E5          	PUSH	HL		;save second message pointer.
1590   E4E6 CD C9 E5    	CALL	OUTCRLF		;send (cr)(lf).
1591   E4E9 3A 42 E7    	LD	A,(ACTIVE)	;get active drive.
1592   E4EC C6 41       	ADD	A,'A'		;make ascii.
TASM Z80 Assembler.               cpm22.z80                        page 32
 CP/M Ver 2.2 BDOS

1593   E4EE 32 C6 E4    	LD	(BDOSDRV),A	;and put in message.
1594   E4F1 01 BA E4    	LD	BC,BDOSERR	;and print it.
1595   E4F4 CD D3 E5    	CALL	PRTMESG
1596   E4F7 C1          	POP	BC		;print second message line now.
1597   E4F8 CD D3 E5    	CALL	PRTMESG
1598   E4FB             ;
1599   E4FB             ;-------------------------------------------------------------
1600   E4FB             ;   Get an input character. We will check our 1 character
1601   E4FB             ; buffer first. This may be set by the console status routine.
1602   E4FB             ;
1603   E4FB             GETCHAR:
1604   E4FB 21 0E E7    	LD	HL,CHARBUF	;check character buffer.
1605   E4FE 7E          	LD	A,(HL)		;anything present already?
1606   E4FF 36 00       	LD	(HL),0		;...either case clear it.
1607   E501 B7          	OR	A
1608   E502 C0          	RET	NZ		;yes, use it.
1609   E503 C3 09 F2    	JP	CONIN		;nope, go get a character responce.
1610   E506             ;
1611   E506             ;-------------------------------------------------------------
1612   E506             ;   Input and echo a character.
1613   E506             ;
1614   E506             GETECHO:
1615   E506 CD FB E4    	CALL	GETCHAR		;input a character.
1616   E509 CD 14 E5    	CALL	CHKCHAR		;carriage control?
1617   E50C D8          	RET	C		;no, a regular control char so don't echo.
1618   E50D F5          	PUSH	AF		;ok, save character now.
1619   E50E 4F          	LD	C,A
1620   E50F CD 90 E5    	CALL	OUTCON		;and echo it.
1621   E512 F1          	POP	AF		;get character and return.
1622   E513 C9          	RET	
1623   E514             ;
1624   E514             ;-------------------------------------------------------------
1625   E514             ;   Check character in (A). Set the zero flag on a carriage
1626   E514             ; control character and the carry flag on any other control
1627   E514             ; character.
1628   E514             ;
1629   E514             CHKCHAR:
1630   E514 FE 0D       	CP	CR		;check for carriage return, line feed, backspace,
1631   E516 C8          	RET	Z		;or a tab.
1632   E517 FE 0A       	CP	LF
1633   E519 C8          	RET	Z
1634   E51A FE 09       	CP	TAB
1635   E51C C8          	RET	Z
1636   E51D FE 08       	CP	BS
1637   E51F C8          	RET	Z
1638   E520 FE 20       	CP	' '		;other control char? Set carry flag.
1639   E522 C9          	RET	
1640   E523             ;
1641   E523             ;-------------------------------------------------------------
1642   E523             ;   Check the console during output. Halt on a control-s, then
1643   E523             ; reboot on a control-c. If anything else is ready, clear the
1644   E523             ; zero flag and return (the calling routine may want to do
1645   E523             ; something).
1646   E523             ;
1647   E523             CKCONSOL:
1648   E523 3A 0E E7    	LD	A,(CHARBUF)	;check buffer.
1649   E526 B7          	OR	A		;if anything, just return without checking.
1650   E527 C2 45 E5    	JP	NZ,CKCON2
1651   E52A CD 06 F2    	CALL	CONST		;nothing in buffer. Check console.
TASM Z80 Assembler.               cpm22.z80                        page 33
 CP/M Ver 2.2 BDOS

1652   E52D E6 01       	AND	01H		;look at bit 0.
1653   E52F C8          	RET	Z		;return if nothing.
1654   E530 CD 09 F2    	CALL	CONIN		;ok, get it.
1655   E533 FE 13       	CP	CNTRLS		;if not control-s, return with zero cleared.
1656   E535 C2 42 E5    	JP	NZ,CKCON1
1657   E538 CD 09 F2    	CALL	CONIN		;halt processing until another char
1658   E53B FE 03       	CP	CNTRLC		;is typed. Control-c?
1659   E53D CA 00 00    	JP	Z,0		;yes, reboot now.
1660   E540 AF          	XOR	A		;no, just pretend nothing was ever ready.
1661   E541 C9          	RET	
1662   E542             CKCON1:
1663   E542 32 0E E7    	LD	(CHARBUF),A	;save character in buffer for later processing.
1664   E545             CKCON2:
1665   E545 3E 01       	LD	A,1		;set (A) to non zero to mean something is ready.
1666   E547 C9          	RET	
1667   E548             ;
1668   E548             ;-------------------------------------------------------------
1669   E548             ;   Output (C) to the screen. If the printer flip-flop flag
1670   E548             ; is set, we will send character to printer also. The console
1671   E548             ; will be checked in the process.
1672   E548             ;
1673   E548             OUTCHAR:
1674   E548 3A 0A E7    	LD	A,(OUTFLAG)	;check output flag.
1675   E54B B7          	OR	A		;anything and we won't generate output.
1676   E54C C2 62 E5    	JP	NZ,OUTCHR1
1677   E54F C5          	PUSH	BC
1678   E550 CD 23 E5    	CALL	CKCONSOL	;check console (we don't care whats there).
1679   E553 C1          	POP	BC
1680   E554 C5          	PUSH	BC
1681   E555 CD 0C F2    	CALL	CONOUT		;output (C) to the screen.
1682   E558 C1          	POP	BC
1683   E559 C5          	PUSH	BC
1684   E55A 3A 0D E7    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
1685   E55D B7          	OR	A
1686   E55E C4 0F F2    	CALL	NZ,LIST		;print it also if non-zero.
1687   E561 C1          	POP	BC
1688   E562             OUTCHR1:
1689   E562 79          	LD	A,C		;update cursors position.
1690   E563 21 0C E7    	LD	HL,CURPOS
1691   E566 FE 7F       	CP	DEL		;rubouts don't do anything here.
1692   E568 C8          	RET	Z
1693   E569 34          	INC	(HL)		;bump line pointer.
1694   E56A FE 20       	CP	' '		;and return if a normal character.
1695   E56C D0          	RET	NC
1696   E56D 35          	DEC	(HL)		;restore and check for the start of the line.
1697   E56E 7E          	LD	A,(HL)
1698   E56F B7          	OR	A
1699   E570 C8          	RET	Z		;ingnore control characters at the start of the line.
1700   E571 79          	LD	A,C
1701   E572 FE 08       	CP	BS		;is it a backspace?
1702   E574 C2 79 E5    	JP	NZ,OUTCHR2
1703   E577 35          	DEC	(HL)		;yes, backup pointer.
1704   E578 C9          	RET	
1705   E579             OUTCHR2:
1706   E579 FE 0A       	CP	LF		;is it a line feed?
1707   E57B C0          	RET	NZ		;ignore anything else.
1708   E57C 36 00       	LD	(HL),0		;reset pointer to start of line.
1709   E57E C9          	RET	
1710   E57F             ;
TASM Z80 Assembler.               cpm22.z80                        page 34
 CP/M Ver 2.2 BDOS

1711   E57F             ;-------------------------------------------------------------
1712   E57F             ;   Output (A) to the screen. If it is a control character
1713   E57F             ; (other than carriage control), use ^x format.
1714   E57F             ;
1715   E57F             SHOWIT:
1716   E57F 79          	LD	A,C
1717   E580 CD 14 E5    	CALL	CHKCHAR		;check character.
1718   E583 D2 90 E5    	JP	NC,OUTCON	;not a control, use normal output.
1719   E586 F5          	PUSH	AF
1720   E587 0E 5E       	LD	C,'^'		;for a control character, preceed it with '^'.
1721   E589 CD 48 E5    	CALL	OUTCHAR
1722   E58C F1          	POP	AF
1723   E58D F6 40       	OR	'@'		;and then use the letter equivelant.
1724   E58F 4F          	LD	C,A
1725   E590             ;
1726   E590             ;-------------------------------------------------------------
1727   E590             ;   Function to output (C) to the console device and expand tabs
1728   E590             ; if necessary.
1729   E590             ;
1730   E590             OUTCON:
1731   E590 79          	LD	A,C
1732   E591 FE 09       	CP	TAB		;is it a tab?
1733   E593 C2 48 E5    	JP	NZ,OUTCHAR	;use regular output.
1734   E596             OUTCON1:
1735   E596 0E 20       	LD	C,' '		;yes it is, use spaces instead.
1736   E598 CD 48 E5    	CALL	OUTCHAR
1737   E59B 3A 0C E7    	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
1738   E59E             
1739   E59E E6 07       	AND	07H		;position.
1740   E5A0 C2 96 E5    	JP	NZ,OUTCON1
1741   E5A3 C9          	RET	
1742   E5A4             ;
1743   E5A4             ;-------------------------------------------------------------
1744   E5A4             ;   Echo a backspace character. Erase the prevoius character
1745   E5A4             ; on the screen.
1746   E5A4             ;
1747   E5A4             BACKUP:
1748   E5A4 CD AC E5    	CALL	BACKUP1		;backup the screen 1 place.
1749   E5A7 0E 20       	LD	C,' '		;then blank that character.
1750   E5A9 CD 0C F2    	CALL	CONOUT
1751   E5AC             BACKUP1:
1752   E5AC 0E 08       	LD	C,BS		;then back space once more.
1753   E5AE C3 0C F2    	JP	CONOUT
1754   E5B1             ;
1755   E5B1             ;-------------------------------------------------------------
1756   E5B1             ;   Signal a deleted line. Print a '#' at the end and start
1757   E5B1             ; over.
1758   E5B1             ;
1759   E5B1             NEWLINE:
1760   E5B1 0E 23       	LD	C,'#'
1761   E5B3 CD 48 E5    	CALL	OUTCHAR		;print this.
1762   E5B6 CD C9 E5    	CALL	OUTCRLF		;start new line.
1763   E5B9             NEWLN1:
1764   E5B9 3A 0C E7    	LD	A,(CURPOS)	;move the cursor to the starting position.
1765   E5BC 21 0B E7    	LD	HL,STARTING
1766   E5BF BE          	CP	(HL)
1767   E5C0 D0          	RET	NC		;there yet?
1768   E5C1 0E 20       	LD	C,' '
1769   E5C3 CD 48 E5    	CALL	OUTCHAR		;nope, keep going.
TASM Z80 Assembler.               cpm22.z80                        page 35
 CP/M Ver 2.2 BDOS

1770   E5C6 C3 B9 E5    	JP	NEWLN1
1771   E5C9             ;
1772   E5C9             ;-------------------------------------------------------------
1773   E5C9             ;   Output a (cr) (lf) to the console device (screen).
1774   E5C9             ;
1775   E5C9             OUTCRLF:
1776   E5C9 0E 0D       	LD	C,CR
1777   E5CB CD 48 E5    	CALL	OUTCHAR
1778   E5CE 0E 0A       	LD	C,LF
1779   E5D0 C3 48 E5    	JP	OUTCHAR
1780   E5D3             ;
1781   E5D3             ;-------------------------------------------------------------
1782   E5D3             ;   Print message pointed to by (BC). It will end with a '$'.
1783   E5D3             ;
1784   E5D3             PRTMESG:
1785   E5D3 0A          	LD	A,(BC)		;check for terminating character.
1786   E5D4 FE 24       	CP	'$'
1787   E5D6 C8          	RET	Z
1788   E5D7 03          	INC	BC
1789   E5D8 C5          	PUSH	BC		;otherwise, bump pointer and print it.
1790   E5D9 4F          	LD	C,A
1791   E5DA CD 90 E5    	CALL	OUTCON
1792   E5DD C1          	POP	BC
1793   E5DE C3 D3 E5    	JP	PRTMESG
1794   E5E1             ;
1795   E5E1             ;-------------------------------------------------------------
1796   E5E1             ;   Function to execute a buffered read.
1797   E5E1             ;
1798   E5E1             RDBUFF:
1799   E5E1 3A 0C E7    	LD	A,(CURPOS)	;use present location as starting one.
1800   E5E4 32 0B E7    	LD	(STARTING),A
1801   E5E7 2A 43 E7    	LD	HL,(PARAMS)	;get the maximum buffer space.
1802   E5EA 4E          	LD	C,(HL)
1803   E5EB 23          	INC	HL		;point to first available space.
1804   E5EC E5          	PUSH	HL		;and save.
1805   E5ED 06 00       	LD	B,0		;keep a character count.
1806   E5EF             RDBUF1:
1807   E5EF C5          	PUSH	BC
1808   E5F0 E5          	PUSH	HL
1809   E5F1             RDBUF2:
1810   E5F1 CD FB E4    	CALL	GETCHAR		;get the next input character.
1811   E5F4 E6 7F       	AND	7FH		;strip bit 7.
1812   E5F6 E1          	POP	HL		;reset registers.
1813   E5F7 C1          	POP	BC
1814   E5F8 FE 0D       	CP	CR		;en of the line?
1815   E5FA CA C1 E6    	JP	Z,RDBUF17
1816   E5FD FE 0A       	CP	LF
1817   E5FF CA C1 E6    	JP	Z,RDBUF17
1818   E602 FE 08       	CP	BS		;how about a backspace?
1819   E604 C2 16 E6    	JP	NZ,RDBUF3
1820   E607 78          	LD	A,B		;yes, but ignore at the beginning of the line.
1821   E608 B7          	OR	A
1822   E609 CA EF E5    	JP	Z,RDBUF1
1823   E60C 05          	DEC	B		;ok, update counter.
1824   E60D 3A 0C E7    	LD	A,(CURPOS)	;if we backspace to the start of the line,
1825   E610 32 0A E7    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
1826   E613 C3 70 E6    	JP	RDBUF10
1827   E616             RDBUF3:
1828   E616 FE 7F       	CP	DEL		;user typed a rubout?
TASM Z80 Assembler.               cpm22.z80                        page 36
 CP/M Ver 2.2 BDOS

1829   E618 C2 26 E6    	JP	NZ,RDBUF4
1830   E61B 78          	LD	A,B		;ignore at the start of the line.
1831   E61C B7          	OR	A
1832   E61D CA EF E5    	JP	Z,RDBUF1
1833   E620 7E          	LD	A,(HL)		;ok, echo the prevoius character.
1834   E621 05          	DEC	B		;and reset pointers (counters).
1835   E622 2B          	DEC	HL
1836   E623 C3 A9 E6    	JP	RDBUF15
1837   E626             RDBUF4:
1838   E626 FE 05       	CP	CNTRLE		;physical end of line?
1839   E628 C2 37 E6    	JP	NZ,RDBUF5
1840   E62B C5          	PUSH	BC		;yes, do it.
1841   E62C E5          	PUSH	HL
1842   E62D CD C9 E5    	CALL	OUTCRLF
1843   E630 AF          	XOR	A		;and update starting position.
1844   E631 32 0B E7    	LD	(STARTING),A
1845   E634 C3 F1 E5    	JP	RDBUF2
1846   E637             RDBUF5:
1847   E637 FE 10       	CP	CNTRLP		;control-p?
1848   E639 C2 48 E6    	JP	NZ,RDBUF6
1849   E63C E5          	PUSH	HL		;yes, flip the print flag filp-flop byte.
1850   E63D 21 0D E7    	LD	HL,PRTFLAG
1851   E640 3E 01       	LD	A,1		;PRTFLAG=1-PRTFLAG
1852   E642 96          	SUB	(HL)
1853   E643 77          	LD	(HL),A
1854   E644 E1          	POP	HL
1855   E645 C3 EF E5    	JP	RDBUF1
1856   E648             RDBUF6:
1857   E648 FE 18       	CP	CNTRLX		;control-x (cancel)?
1858   E64A C2 5F E6    	JP	NZ,RDBUF8
1859   E64D E1          	POP	HL
1860   E64E             RDBUF7:
1861   E64E 3A 0B E7    	LD	A,(STARTING)	;yes, backup the cursor to here.
1862   E651 21 0C E7    	LD	HL,CURPOS
1863   E654 BE          	CP	(HL)
1864   E655 D2 E1 E5    	JP	NC,RDBUFF	;done yet?
1865   E658 35          	DEC	(HL)		;no, decrement pointer and output back up one space.
1866   E659 CD A4 E5    	CALL	BACKUP
1867   E65C C3 4E E6    	JP	RDBUF7
1868   E65F             RDBUF8:
1869   E65F FE 15       	CP	CNTRLU		;cntrol-u (cancel line)?
1870   E661 C2 6B E6    	JP	NZ,RDBUF9
1871   E664 CD B1 E5    	CALL	NEWLINE		;start a new line.
1872   E667 E1          	POP	HL
1873   E668 C3 E1 E5    	JP	RDBUFF
1874   E66B             RDBUF9:
1875   E66B FE 12       	CP	CNTRLR		;control-r?
1876   E66D C2 A6 E6    	JP	NZ,RDBUF14
1877   E670             RDBUF10:
1878   E670 C5          	PUSH	BC		;yes, start a new line and retype the old one.
1879   E671 CD B1 E5    	CALL	NEWLINE
1880   E674 C1          	POP	BC
1881   E675 E1          	POP	HL
1882   E676 E5          	PUSH	HL
1883   E677 C5          	PUSH	BC
1884   E678             RDBUF11:
1885   E678 78          	LD	A,B		;done whole line yet?
1886   E679 B7          	OR	A
1887   E67A CA 8A E6    	JP	Z,RDBUF12
TASM Z80 Assembler.               cpm22.z80                        page 37
 CP/M Ver 2.2 BDOS

1888   E67D 23          	INC	HL		;nope, get next character.
1889   E67E 4E          	LD	C,(HL)
1890   E67F 05          	DEC	B		;count it.
1891   E680 C5          	PUSH	BC
1892   E681 E5          	PUSH	HL
1893   E682 CD 7F E5    	CALL	SHOWIT		;and display it.
1894   E685 E1          	POP	HL
1895   E686 C1          	POP	BC
1896   E687 C3 78 E6    	JP	RDBUF11
1897   E68A             RDBUF12:
1898   E68A E5          	PUSH	HL		;done with line. If we were displaying
1899   E68B 3A 0A E7    	LD	A,(OUTFLAG)	;then update cursor position.
1900   E68E B7          	OR	A
1901   E68F CA F1 E5    	JP	Z,RDBUF2
1902   E692 21 0C E7    	LD	HL,CURPOS	;because this line is shorter, we must
1903   E695 96          	SUB	(HL)		;back up the cursor (not the screen however)
1904   E696 32 0A E7    	LD	(OUTFLAG),A	;some number of positions.
1905   E699             RDBUF13:
1906   E699 CD A4 E5    	CALL	BACKUP		;note that as long as (OUTFLAG) is non
1907   E69C 21 0A E7    	LD	HL,OUTFLAG	;zero, the screen will not be changed.
1908   E69F 35          	DEC	(HL)
1909   E6A0 C2 99 E6    	JP	NZ,RDBUF13
1910   E6A3 C3 F1 E5    	JP	RDBUF2		;now just get the next character.
1911   E6A6             ;
1912   E6A6             ;   Just a normal character, put this in our buffer and echo.
1913   E6A6             ;
1914   E6A6             RDBUF14:
1915   E6A6 23          	INC	HL
1916   E6A7 77          	LD	(HL),A		;store character.
1917   E6A8 04          	INC	B		;and count it.
1918   E6A9             RDBUF15:
1919   E6A9 C5          	PUSH	BC
1920   E6AA E5          	PUSH	HL
1921   E6AB 4F          	LD	C,A		;echo it now.
1922   E6AC CD 7F E5    	CALL	SHOWIT
1923   E6AF E1          	POP	HL
1924   E6B0 C1          	POP	BC
1925   E6B1 7E          	LD	A,(HL)		;was it an abort request?
1926   E6B2 FE 03       	CP	CNTRLC		;control-c abort?
1927   E6B4 78          	LD	A,B
1928   E6B5 C2 BD E6    	JP	NZ,RDBUF16
1929   E6B8 FE 01       	CP	1		;only if at start of line.
1930   E6BA CA 00 00    	JP	Z,0
1931   E6BD             RDBUF16:
1932   E6BD B9          	CP	C		;nope, have we filled the buffer?
1933   E6BE DA EF E5    	JP	C,RDBUF1
1934   E6C1             RDBUF17:
1935   E6C1 E1          	POP	HL		;yes end the line and return.
1936   E6C2 70          	LD	(HL),B
1937   E6C3 0E 0D       	LD	C,CR
1938   E6C5 C3 48 E5    	JP	OUTCHAR		;output (cr) and return.
1939   E6C8             ;
1940   E6C8             ;-------------------------------------------------------------
1941   E6C8             ;   Function to get a character from the console device.
1942   E6C8             ;
1943   E6C8             GETCON:
1944   E6C8 CD 06 E5    	CALL	GETECHO		;get and echo.
1945   E6CB C3 01 E7    	JP	SETSTAT		;save status and return.
1946   E6CE             ;
TASM Z80 Assembler.               cpm22.z80                        page 38
 CP/M Ver 2.2 BDOS

1947   E6CE             ;-------------------------------------------------------------
1948   E6CE             ;   Function to get a character from the tape reader device.
1949   E6CE             ;
1950   E6CE             GETRDR:
1951   E6CE CD 15 F2    	CALL	READER		;get a character from reader
1952   E6D1 C3 01 E7    	JP	SETSTAT		;set status and return
1953   E6D4             ;
1954   E6D4             ;-------------------------------------------------------------
1955   E6D4             ;  Function to perform direct console i/o. If (C) contains (FF)
1956   E6D4             ; then this is an input request. If (C) contains (FE) then
1957   E6D4             ; this is a status request. Otherwise we are to output (C).
1958   E6D4             ;
1959   E6D4             DIRCIO:
1960   E6D4 79          	LD	A,C		;test for (FF).
1961   E6D5 3C          	INC	A
1962   E6D6 CA E0 E6    	JP	Z,DIRC1
1963   E6D9 3C          	INC	A		;test for (FE).
1964   E6DA CA 06 F2    	JP	Z,CONST
1965   E6DD C3 0C F2    	JP	CONOUT		;just output (C).
1966   E6E0             DIRC1:
1967   E6E0 CD 06 F2    	CALL	CONST		;this is an input request.
1968   E6E3 B7          	OR	A
1969   E6E4 CA 92 F1    	JP	Z,GOBACK1	;not ready? Just return (directly).
1970   E6E7 CD 09 F2    	CALL	CONIN		;yes, get character.
1971   E6EA C3 01 E7    	JP	SETSTAT		;set status and return.
1972   E6ED             ;
1973   E6ED             ;-------------------------------------------------------------
1974   E6ED             ;   Function to return the i/o byte.
1975   E6ED             ;
1976   E6ED             GETIOB:
1977   E6ED 3A 03 00    	LD	A,(IOBYTE)
1978   E6F0 C3 01 E7    	JP	SETSTAT
1979   E6F3             ;
1980   E6F3             ;-------------------------------------------------------------
1981   E6F3             ;   Function to set the i/o byte.
1982   E6F3             ;
1983   E6F3             SETIOB:
1984   E6F3 21 03 00    	LD	HL,IOBYTE
1985   E6F6 71          	LD	(HL),C
1986   E6F7 C9          	RET	
1987   E6F8             ;
1988   E6F8             ;-------------------------------------------------------------
1989   E6F8             ;   Function to print the character string pointed to by (DE)
1990   E6F8             ; on the console device. The string ends with a '$'.
1991   E6F8             ;
1992   E6F8             PRTSTR:
1993   E6F8 EB          	EX	DE,HL
1994   E6F9 4D          	LD	C,L
1995   E6FA 44          	LD	B,H		;now (BC) points to it.
1996   E6FB C3 D3 E5    	JP	PRTMESG
1997   E6FE             ;
1998   E6FE             ;-------------------------------------------------------------
1999   E6FE             ;   Function to interigate the console device.
2000   E6FE             ;
2001   E6FE             GETCSTS:
2002   E6FE CD 23 E5    	CALL	CKCONSOL
2003   E701             ;
2004   E701             ;   Get here to set the status and return to the cleanup
2005   E701             ; section. Then back to the user.
TASM Z80 Assembler.               cpm22.z80                        page 39
 CP/M Ver 2.2 BDOS

2006   E701             ;
2007   E701             SETSTAT:
2008   E701 32 45 E7    	LD	(STATUS),A
2009   E704             RTN:
2010   E704 C9          	RET	
2011   E705             ;
2012   E705             ;-------------------------------------------------------------
2013   E705             ;   Set the status to 1 (read or write error code).
2014   E705             ;
2015   E705             IOERR1:
2016   E705 3E 01       	LD	A,1
2017   E707 C3 01 E7    	JP	SETSTAT
2018   E70A             ;
2019   E70A             ;-------------------------------------------------------------
2020   E70A             OUTFLAG:
2021   E70A 00          	.BYTE	0		;output flag (non zero means no output).
2022   E70B             STARTING:
2023   E70B 02          	.BYTE	2		;starting position for cursor.
2024   E70C             CURPOS:
2025   E70C 00          	.BYTE	0		;cursor position (0=start of line).
2026   E70D             PRTFLAG:
2027   E70D 00          	.BYTE	0		;printer flag (control-p toggle). List if non zero.
2028   E70E             CHARBUF:
2029   E70E 00          	.BYTE	0		;single input character buffer.
2030   E70F             ;
2031   E70F             ;-------------------------------------------------------------
2032   E70F             ;   Stack area for BDOS calls.
2033   E70F             ;
2034   E70F             USRSTACK:
2035   E70F 00 00       	.WORD	0		;save users stack pointer here.
2036   E711             ;
2037   E711 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2037   E715 00 00 00 00 
2038   E719 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2038   E71D 00 00 00 00 
2039   E721 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2039   E725 00 00 00 00 
2040   E729 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2040   E72D 00 00 00 00 
2041   E731 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2041   E735 00 00 00 00 
2042   E739 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
2042   E73D 00 00 00 00 
2043   E741             
2044   E741             STKAREA .EQU	$		;end of stack area.
2045   E741             ;
2046   E741             ;-------------------------------------------------------------
2047   E741             USERNO:
2048   E741 00          	.BYTE	0		;current user number.
2049   E742             ACTIVE:
2050   E742 00          	.BYTE	0		;currently active drive.
2051   E743             PARAMS:
2052   E743 00 00       	.WORD	0		;save (DE) parameters here on entry.
2053   E745             STATUS:
2054   E745 00 00       	.WORD	0		;status returned from bdos function.
2055   E747             ;
2056   E747             ;-------------------------------------------------------------
2057   E747             ;   Select error occured, jump to error routine.
2058   E747             ;
TASM Z80 Assembler.               cpm22.z80                        page 40
 CP/M Ver 2.2 BDOS

2059   E747             SLCTERR:
2060   E747 21 0B E4    	LD	HL,BADSLCT
2061   E74A             ;
2062   E74A             ;-------------------------------------------------------------
2063   E74A             ;   Jump to (HL) indirectly.
2064   E74A             ;
2065   E74A             JUMPHL:
2066   E74A 5E          	LD	E,(HL)
2067   E74B 23          	INC	HL
2068   E74C 56          	LD	D,(HL)		;now (DE) contain the desired address.
2069   E74D EB          	EX	DE,HL
2070   E74E E9          	JP	(HL)
2071   E74F             ;
2072   E74F             ;-------------------------------------------------------------
2073   E74F             ;   Block move. (DE) to (HL), (C) bytes total.
2074   E74F             ;
2075   E74F             DE2HL:
2076   E74F 0C          	INC	C		;is count down to zero?
2077   E750             DE2HL1:
2078   E750 0D          	DEC	C
2079   E751 C8          	RET	Z		;yes, we are done.
2080   E752 1A          	LD	A,(DE)		;no, move one more byte.
2081   E753 77          	LD	(HL),A
2082   E754 13          	INC	DE
2083   E755 23          	INC	HL
2084   E756 C3 50 E7    	JP	DE2HL1		;and repeat.
2085   E759             ;
2086   E759             ;-------------------------------------------------------------
2087   E759             ;   Select the desired drive.
2088   E759             ;
2089   E759             SELECT:
2090   E759 3A 42 E7    	LD	A,(ACTIVE)	;get active disk.
2091   E75C 4F          	LD	C,A
2092   E75D CD 1B F2    	CALL	SELDSK		;select it.
2093   E760 7C          	LD	A,H		;valid drive?
2094   E761 B5          	OR	L		;valid drive?
2095   E762 C8          	RET	Z		;return if not.
2096   E763             ;
2097   E763             ;   Here, the BIOS returned the address of the parameter block
2098   E763             ; in (HL). We will extract the necessary pointers and save them.
2099   E763             ;
2100   E763 5E          	LD	E,(HL)		;yes, get address of translation table into (DE).
2101   E764 23          	INC	HL
2102   E765 56          	LD	D,(HL)
2103   E766 23          	INC	HL
2104   E767 22 B4 F1    	LD	(SCRATCH1),HL	;save pointers to scratch areas.
2105   E76A 23          	INC	HL
2106   E76B 23          	INC	HL
2107   E76C 22 B6 F1    	LD	(SCRATCH2),HL	;ditto.
2108   E76F 23          	INC	HL
2109   E770 23          	INC	HL
2110   E771 22 B8 F1    	LD	(SCRATCH3),HL	;ditto.
2111   E774 23          	INC	HL
2112   E775 23          	INC	HL
2113   E776 EB          	EX	DE,HL		;now save the translation table address.
2114   E777 22 D1 F1    	LD	(XLATE),HL
2115   E77A 21 BA F1    	LD	HL,DIRBUF	;put the next 8 bytes here.
2116   E77D 0E 08       	LD	C,8		;they consist of the directory buffer
2117   E77F CD 4F E7    	CALL	DE2HL		;pointer, parameter block pointer,
TASM Z80 Assembler.               cpm22.z80                        page 41
 CP/M Ver 2.2 BDOS

2118   E782 2A BC F1    	LD	HL,(DISKPB)	;check and allocation vectors.
2119   E785 EB          	EX	DE,HL
2120   E786 21 C2 F1    	LD	HL,SECTORS	;move parameter block into our ram.
2121   E789 0E 0F       	LD	C,15		;it is 15 bytes long.
2122   E78B CD 4F E7    	CALL	DE2HL
2123   E78E 2A C7 F1    	LD	HL,(DSKSIZE)	;check disk size.
2124   E791 7C          	LD	A,H		;more than 256 blocks on this?
2125   E792 21 DE F1    	LD	HL,BIGDISK
2126   E795 36 FF       	LD	(HL),0FFH	;set to samll.
2127   E797 B7          	OR	A
2128   E798 CA 9D E7    	JP	Z,SELECT1
2129   E79B 36 00       	LD	(HL),0		;wrong, set to large.
2130   E79D             SELECT1:
2131   E79D 3E FF       	LD	A,0FFH		;clear the zero flag.
2132   E79F B7          	OR	A
2133   E7A0 C9          	RET	
2134   E7A1             ;
2135   E7A1             ;-------------------------------------------------------------
2136   E7A1             ;   Routine to home the disk track head and clear pointers.
2137   E7A1             ;
2138   E7A1             HOMEDRV:
2139   E7A1 CD 18 F2    	CALL	HOME		;home the head.
2140   E7A4 AF          	XOR	A
2141   E7A5 2A B6 F1    	LD	HL,(SCRATCH2)	;set our track pointer also.
2142   E7A8 77          	LD	(HL),A
2143   E7A9 23          	INC	HL
2144   E7AA 77          	LD	(HL),A
2145   E7AB 2A B8 F1    	LD	HL,(SCRATCH3)	;and our sector pointer.
2146   E7AE 77          	LD	(HL),A
2147   E7AF 23          	INC	HL
2148   E7B0 77          	LD	(HL),A
2149   E7B1 C9          	RET	
2150   E7B2             ;
2151   E7B2             ;-------------------------------------------------------------
2152   E7B2             ;   Do the actual disk read and check the error return status.
2153   E7B2             ;
2154   E7B2             DOREAD:
2155   E7B2 CD 27 F2    	CALL	READ
2156   E7B5 C3 BB E7    	JP	IORET
2157   E7B8             ;
2158   E7B8             ;-------------------------------------------------------------
2159   E7B8             ;   Do the actual disk write and handle any bios error.
2160   E7B8             ;
2161   E7B8             DOWRITE:
2162   E7B8 CD 2A F2    	CALL	WRITE
2163   E7BB             IORET:
2164   E7BB B7          	OR	A
2165   E7BC C8          	RET	Z		;return unless an error occured.
2166   E7BD 21 09 E4    	LD	HL,BADSCTR	;bad read/write on this sector.
2167   E7C0 C3 4A E7    	JP	JUMPHL
2168   E7C3             ;
2169   E7C3             ;-------------------------------------------------------------
2170   E7C3             ;   Routine to select the track and sector that the desired
2171   E7C3             ; block number falls in.
2172   E7C3             ;
2173   E7C3             TRKSEC:
2174   E7C3 2A EB F1    	LD	HL,(FILEPOS)	;get position of last accessed file
2175   E7C6 0E 02       	LD	C,2		;in directory and compute sector #.
2176   E7C8 CD EA E8    	CALL	SHIFTR		;sector #=file-position/4.
TASM Z80 Assembler.               cpm22.z80                        page 42
 CP/M Ver 2.2 BDOS

2177   E7CB 22 E6 F1    	LD	(BLKNMBR),HL	;save this as the block number of interest.
2178   E7CE 22 ED F1    	LD	(CKSUMTBL),HL	;what's it doing here too?
2179   E7D1             ;
2180   E7D1             ;   if the sector number has already been set (BLKNMBR), enter
2181   E7D1             ; at this point.
2182   E7D1             ;
2183   E7D1             TRKSEC1:
2184   E7D1 21 E6 F1    	LD	HL,BLKNMBR
2185   E7D4 4E          	LD	C,(HL)		;move sector number into (BC).
2186   E7D5 23          	INC	HL
2187   E7D6 46          	LD	B,(HL)
2188   E7D7 2A B8 F1    	LD	HL,(SCRATCH3)	;get current sector number and
2189   E7DA 5E          	LD	E,(HL)		;move this into (DE).
2190   E7DB 23          	INC	HL
2191   E7DC 56          	LD	D,(HL)
2192   E7DD 2A B6 F1    	LD	HL,(SCRATCH2)	;get current track number.
2193   E7E0 7E          	LD	A,(HL)		;and this into (HL).
2194   E7E1 23          	INC	HL
2195   E7E2 66          	LD	H,(HL)
2196   E7E3 6F          	LD	L,A
2197   E7E4             TRKSEC2:
2198   E7E4 79          	LD	A,C		;is desired sector before current one?
2199   E7E5 93          	SUB	E
2200   E7E6 78          	LD	A,B
2201   E7E7 9A          	SBC	A,D
2202   E7E8 D2 FA E7    	JP	NC,TRKSEC3
2203   E7EB E5          	PUSH	HL		;yes, decrement sectors by one track.
2204   E7EC 2A C2 F1    	LD	HL,(SECTORS)	;get sectors per track.
2205   E7EF 7B          	LD	A,E
2206   E7F0 95          	SUB	L
2207   E7F1 5F          	LD	E,A
2208   E7F2 7A          	LD	A,D
2209   E7F3 9C          	SBC	A,H
2210   E7F4 57          	LD	D,A		;now we have backed up one full track.
2211   E7F5 E1          	POP	HL
2212   E7F6 2B          	DEC	HL		;adjust track counter.
2213   E7F7 C3 E4 E7    	JP	TRKSEC2
2214   E7FA             TRKSEC3:
2215   E7FA E5          	PUSH	HL		;desired sector is after current one.
2216   E7FB 2A C2 F1    	LD	HL,(SECTORS)	;get sectors per track.
2217   E7FE 19          	ADD	HL,DE		;bump sector pointer to next track.
2218   E7FF DA 0F E8    	JP	C,TRKSEC4
2219   E802 79          	LD	A,C		;is desired sector now before current one?
2220   E803 95          	SUB	L
2221   E804 78          	LD	A,B
2222   E805 9C          	SBC	A,H
2223   E806 DA 0F E8    	JP	C,TRKSEC4
2224   E809 EB          	EX	DE,HL		;not yes, increment track counter
2225   E80A E1          	POP	HL		;and continue until it is.
2226   E80B 23          	INC	HL
2227   E80C C3 FA E7    	JP	TRKSEC3
2228   E80F             ;
2229   E80F             ;   here we have determined the track number that contains the
2230   E80F             ; desired sector.
2231   E80F             ;
2232   E80F             TRKSEC4:
2233   E80F E1          	POP	HL		;get track number (HL).
2234   E810 C5          	PUSH	BC
2235   E811 D5          	PUSH	DE
TASM Z80 Assembler.               cpm22.z80                        page 43
 CP/M Ver 2.2 BDOS

2236   E812 E5          	PUSH	HL
2237   E813 EB          	EX	DE,HL
2238   E814 2A CF F1    	LD	HL,(OFFSET)	;adjust for first track offset.
2239   E817 19          	ADD	HL,DE
2240   E818 44          	LD	B,H
2241   E819 4D          	LD	C,L
2242   E81A CD 1E F2    	CALL	SETTRK		;select this track.
2243   E81D D1          	POP	DE		;reset current track pointer.
2244   E81E 2A B6 F1    	LD	HL,(SCRATCH2)
2245   E821 73          	LD	(HL),E
2246   E822 23          	INC	HL
2247   E823 72          	LD	(HL),D
2248   E824 D1          	POP	DE
2249   E825 2A B8 F1    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
2250   E828 73          	LD	(HL),E
2251   E829 23          	INC	HL
2252   E82A 72          	LD	(HL),D
2253   E82B C1          	POP	BC
2254   E82C 79          	LD	A,C		;now subtract the desired one.
2255   E82D 93          	SUB	E		;to make it relative (1-# sectors/track).
2256   E82E 4F          	LD	C,A
2257   E82F 78          	LD	A,B
2258   E830 9A          	SBC	A,D
2259   E831 47          	LD	B,A
2260   E832 2A D1 F1    	LD	HL,(XLATE)	;translate this sector according to this table.
2261   E835 EB          	EX	DE,HL
2262   E836 CD 30 F2    	CALL	SECTRN		;let the bios translate it.
2263   E839 4D          	LD	C,L
2264   E83A 44          	LD	B,H
2265   E83B C3 21 F2    	JP	SETSEC		;and select it.
2266   E83E             ;
2267   E83E             ;-------------------------------------------------------------
2268   E83E             ;   Compute block number from record number (SAVNREC) and
2269   E83E             ; extent number (SAVEXT).
2270   E83E             ;
2271   E83E             GETBLOCK:
2272   E83E 21 C4 F1    	LD	HL,BLKSHFT	;get logical to physical conversion.
2273   E841 4E          	LD	C,(HL)		;note that this is base 2 log of ratio.
2274   E842 3A E4 F1    	LD	A,(SAVNREC)	;get record number.
2275   E845             GETBLK1:
2276   E845 B7          	OR	A		;compute (A)=(A)/2^BLKSHFT.
2277   E846 1F          	RRA	
2278   E847 0D          	DEC	C
2279   E848 C2 45 E8    	JP	NZ,GETBLK1
2280   E84B 47          	LD	B,A		;save result in (B).
2281   E84C 3E 08       	LD	A,8
2282   E84E 96          	SUB	(HL)
2283   E84F 4F          	LD	C,A		;compute (C)=8-BLKSHFT.
2284   E850 3A E3 F1    	LD	A,(SAVEXT)
2285   E853             GETBLK2:
2286   E853 0D          	DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
2287   E854 CA 5C E8    	JP	Z,GETBLK3
2288   E857 B7          	OR	A
2289   E858 17          	RLA	
2290   E859 C3 53 E8    	JP	GETBLK2
2291   E85C             GETBLK3:
2292   E85C 80          	ADD	A,B
2293   E85D C9          	RET	
2294   E85E             ;
TASM Z80 Assembler.               cpm22.z80                        page 44
 CP/M Ver 2.2 BDOS

2295   E85E             ;-------------------------------------------------------------
2296   E85E             ;   Routine to extract the (BC) block byte from the fcb pointed
2297   E85E             ; to by (PARAMS). If this is a big-disk, then these are 16 bit
2298   E85E             ; block numbers, else they are 8 bit numbers.
2299   E85E             ; Number is returned in (HL).
2300   E85E             ;
2301   E85E             EXTBLK:
2302   E85E 2A 43 E7    	LD	HL,(PARAMS)	;get fcb address.
2303   E861 11 10 00    	LD	DE,16		;block numbers start 16 bytes into fcb.
2304   E864 19          	ADD	HL,DE
2305   E865 09          	ADD	HL,BC
2306   E866 3A DE F1    	LD	A,(BIGDISK)	;are we using a big-disk?
2307   E869 B7          	OR	A
2308   E86A CA 71 E8    	JP	Z,EXTBLK1
2309   E86D 6E          	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
2310   E86E 26 00       	LD	H,0
2311   E870 C9          	RET	
2312   E871             ;
2313   E871             EXTBLK1:
2314   E871 09          	ADD	HL,BC		;yes, extract a 16 bit number.
2315   E872 5E          	LD	E,(HL)
2316   E873 23          	INC	HL
2317   E874 56          	LD	D,(HL)
2318   E875 EB          	EX	DE,HL		;return in (HL).
2319   E876 C9          	RET	
2320   E877             ;
2321   E877             ;-------------------------------------------------------------
2322   E877             ;   Compute block number.
2323   E877             ;
2324   E877             COMBLK:
2325   E877 CD 3E E8    	CALL	GETBLOCK
2326   E87A 4F          	LD	C,A
2327   E87B 06 00       	LD	B,0
2328   E87D CD 5E E8    	CALL	EXTBLK
2329   E880 22 E6 F1    	LD	(BLKNMBR),HL
2330   E883 C9          	RET	
2331   E884             ;
2332   E884             ;-------------------------------------------------------------
2333   E884             ;   Check for a zero block number.
2334   E884             ;
2335   E884             CHKBLK:
2336   E884 2A E6 F1    	LD	HL,(BLKNMBR)
2337   E887 7D          	LD	A,L		;is it zero?
2338   E888 B4          	OR	H
2339   E889 C9          	RET	
2340   E88A             ;
2341   E88A             ;-------------------------------------------------------------
2342   E88A             ;   Adjust physical block (BLKNMBR) and convert to logical
2343   E88A             ; sector (LOGSECT). This is the starting sector of this block.
2344   E88A             ; The actual sector of interest is then added to this and the
2345   E88A             ; resulting sector number is stored back in (BLKNMBR). This
2346   E88A             ; will still have to be adjusted for the track number.
2347   E88A             ;
2348   E88A             LOGICAL:
2349   E88A 3A C4 F1    	LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
2350   E88D 2A E6 F1    	LD	HL,(BLKNMBR)	;get physical sector desired.
2351   E890             LOGICL1:
2352   E890 29          	ADD	HL,HL		;compute logical sector number.
2353   E891 3D          	DEC	A		;note logical sectors are 128 bytes long.
TASM Z80 Assembler.               cpm22.z80                        page 45
 CP/M Ver 2.2 BDOS

2354   E892 C2 90 E8    	JP	NZ,LOGICL1
2355   E895 22 E8 F1    	LD	(LOGSECT),HL	;save logical sector.
2356   E898 3A C5 F1    	LD	A,(BLKMASK)	;get block mask.
2357   E89B 4F          	LD	C,A
2358   E89C 3A E4 F1    	LD	A,(SAVNREC)	;get next sector to access.
2359   E89F A1          	AND	C		;extract the relative position within physical block.
2360   E8A0 B5          	OR	L		;and add it too logical sector.
2361   E8A1 6F          	LD	L,A
2362   E8A2 22 E6 F1    	LD	(BLKNMBR),HL	;and store.
2363   E8A5 C9          	RET	
2364   E8A6             ;
2365   E8A6             ;-------------------------------------------------------------
2366   E8A6             ;   Set (HL) to point to extent byte in fcb.
2367   E8A6             ;
2368   E8A6             SETEXT:
2369   E8A6 2A 43 E7    	LD	HL,(PARAMS)
2370   E8A9 11 0C 00    	LD	DE,12		;it is the twelth byte.
2371   E8AC 19          	ADD	HL,DE
2372   E8AD C9          	RET	
2373   E8AE             ;
2374   E8AE             ;-------------------------------------------------------------
2375   E8AE             ;   Set (HL) to point to record count byte in fcb and (DE) to
2376   E8AE             ; next record number byte.
2377   E8AE             ;
2378   E8AE             SETHLDE:
2379   E8AE 2A 43 E7    	LD	HL,(PARAMS)
2380   E8B1 11 0F 00    	LD	DE,15		;record count byte (#15).
2381   E8B4 19          	ADD	HL,DE
2382   E8B5 EB          	EX	DE,HL
2383   E8B6 21 11 00    	LD	HL,17		;next record number (#32).
2384   E8B9 19          	ADD	HL,DE
2385   E8BA C9          	RET	
2386   E8BB             ;
2387   E8BB             ;-------------------------------------------------------------
2388   E8BB             ;   Save current file data from fcb.
2389   E8BB             ;
2390   E8BB             STRDATA:
2391   E8BB CD AE E8    	CALL	SETHLDE
2392   E8BE 7E          	LD	A,(HL)		;get and store record count byte.
2393   E8BF 32 E4 F1    	LD	(SAVNREC),A
2394   E8C2 EB          	EX	DE,HL
2395   E8C3 7E          	LD	A,(HL)		;get and store next record number byte.
2396   E8C4 32 E2 F1    	LD	(SAVNXT),A
2397   E8C7 CD A6 E8    	CALL	SETEXT		;point to extent byte.
2398   E8CA 3A C6 F1    	LD	A,(EXTMASK)	;get extent mask.
2399   E8CD A6          	AND	(HL)
2400   E8CE 32 E3 F1    	LD	(SAVEXT),A	;and save extent here.
2401   E8D1 C9          	RET	
2402   E8D2             ;
2403   E8D2             ;-------------------------------------------------------------
2404   E8D2             ;   Set the next record to access. If (MODE) is set to 2, then
2405   E8D2             ; the last record byte (SAVNREC) has the correct number to access.
2406   E8D2             ; For sequential access, (MODE) will be equal to 1.
2407   E8D2             ;
2408   E8D2             SETNREC:
2409   E8D2 CD AE E8    	CALL	SETHLDE
2410   E8D5 3A D6 F1    	LD	A,(MODE)	;get sequential flag (=1).
2411   E8D8 FE 02       	CP	2		;a 2 indicates that no adder is needed.
2412   E8DA C2 DE E8    	JP	NZ,STNREC1
TASM Z80 Assembler.               cpm22.z80                        page 46
 CP/M Ver 2.2 BDOS

2413   E8DD AF          	XOR	A		;clear adder (random access?).
2414   E8DE             STNREC1:
2415   E8DE 4F          	LD	C,A
2416   E8DF 3A E4 F1    	LD	A,(SAVNREC)	;get last record number.
2417   E8E2 81          	ADD	A,C		;increment record count.
2418   E8E3 77          	LD	(HL),A		;and set fcb's next record byte.
2419   E8E4 EB          	EX	DE,HL
2420   E8E5 3A E2 F1    	LD	A,(SAVNXT)	;get next record byte from storage.
2421   E8E8 77          	LD	(HL),A		;and put this into fcb as number of records used.
2422   E8E9 C9          	RET	
2423   E8EA             ;
2424   E8EA             ;-------------------------------------------------------------
2425   E8EA             ;   Shift (HL) right (C) bits.
2426   E8EA             ;
2427   E8EA             SHIFTR:
2428   E8EA 0C          	INC	C
2429   E8EB             SHIFTR1:
2430   E8EB 0D          	DEC	C
2431   E8EC C8          	RET	Z
2432   E8ED 7C          	LD	A,H
2433   E8EE B7          	OR	A
2434   E8EF 1F          	RRA	
2435   E8F0 67          	LD	H,A
2436   E8F1 7D          	LD	A,L
2437   E8F2 1F          	RRA	
2438   E8F3 6F          	LD	L,A
2439   E8F4 C3 EB E8    	JP	SHIFTR1
2440   E8F7             ;
2441   E8F7             ;-------------------------------------------------------------
2442   E8F7             ;   Compute the check-sum for the directory buffer. Return
2443   E8F7             ; integer sum in (A).
2444   E8F7             ;
2445   E8F7             CHECKSUM:
2446   E8F7 0E 80       	LD	C,128		;length of buffer.
2447   E8F9 2A BA F1    	LD	HL,(DIRBUF)	;get its location.
2448   E8FC AF          	XOR	A		;clear summation byte.
2449   E8FD             CHKSUM1:
2450   E8FD 86          	ADD	A,(HL)		;and compute sum ignoring carries.
2451   E8FE 23          	INC	HL
2452   E8FF 0D          	DEC	C
2453   E900 C2 FD E8    	JP	NZ,CHKSUM1
2454   E903 C9          	RET	
2455   E904             ;
2456   E904             ;-------------------------------------------------------------
2457   E904             ;   Shift (HL) left (C) bits.
2458   E904             ;
2459   E904             SHIFTL:
2460   E904 0C          	INC	C
2461   E905             SHIFTL1:
2462   E905 0D          	DEC	C
2463   E906 C8          	RET	Z
2464   E907 29          	ADD	HL,HL		;shift left 1 bit.
2465   E908 C3 05 E9    	JP	SHIFTL1
2466   E90B             ;
2467   E90B             ;-------------------------------------------------------------
2468   E90B             ;   Routine to set a bit in a 16 bit value contained in (BC).
2469   E90B             ; The bit set depends on the current drive selection.
2470   E90B             ;
2471   E90B             SETBIT:
TASM Z80 Assembler.               cpm22.z80                        page 47
 CP/M Ver 2.2 BDOS

2472   E90B C5          	PUSH	BC		;save 16 bit word.
2473   E90C 3A 42 E7    	LD	A,(ACTIVE)	;get active drive.
2474   E90F 4F          	LD	C,A
2475   E910 21 01 00    	LD	HL,1
2476   E913 CD 04 E9    	CALL	SHIFTL		;shift bit 0 into place.
2477   E916 C1          	POP	BC		;now 'or' this with the original word.
2478   E917 79          	LD	A,C
2479   E918 B5          	OR	L
2480   E919 6F          	LD	L,A		;low byte done, do high byte.
2481   E91A 78          	LD	A,B
2482   E91B B4          	OR	H
2483   E91C 67          	LD	H,A
2484   E91D C9          	RET	
2485   E91E             ;
2486   E91E             ;-------------------------------------------------------------
2487   E91E             ;   Extract the write protect status bit for the current drive.
2488   E91E             ; The result is returned in (A), bit 0.
2489   E91E             ;
2490   E91E             GETWPRT:
2491   E91E 2A AE F1    	LD	HL,(WRTPRT)	;get status bytes.
2492   E921 3A 42 E7    	LD	A,(ACTIVE)	;which drive is current?
2493   E924 4F          	LD	C,A
2494   E925 CD EA E8    	CALL	SHIFTR		;shift status such that bit 0 is the
2495   E928 7D          	LD	A,L		;one of interest for this drive.
2496   E929 E6 01       	AND	01H		;and isolate it.
2497   E92B C9          	RET	
2498   E92C             ;
2499   E92C             ;-------------------------------------------------------------
2500   E92C             ;   Function to write protect the current disk.
2501   E92C             ;
2502   E92C             WRTPRTD:
2503   E92C 21 AE F1    	LD	HL,WRTPRT	;point to status word.
2504   E92F 4E          	LD	C,(HL)		;set (BC) equal to the status.
2505   E930 23          	INC	HL
2506   E931 46          	LD	B,(HL)
2507   E932 CD 0B E9    	CALL	SETBIT		;and set this bit according to current drive.
2508   E935 22 AE F1    	LD	(WRTPRT),HL	;then save.
2509   E938 2A C9 F1    	LD	HL,(DIRSIZE)	;now save directory size limit.
2510   E93B 23          	INC	HL		;remember the last one.
2511   E93C EB          	EX	DE,HL
2512   E93D 2A B4 F1    	LD	HL,(SCRATCH1)	;and store it here.
2513   E940 73          	LD	(HL),E		;put low byte.
2514   E941 23          	INC	HL
2515   E942 72          	LD	(HL),D		;then high byte.
2516   E943 C9          	RET	
2517   E944             ;
2518   E944             ;-------------------------------------------------------------
2519   E944             ;   Check for a read only file.
2520   E944             ;
2521   E944             CHKROFL:
2522   E944 CD 5E E9    	CALL	FCB2HL		;set (HL) to file entry in directory buffer.
2523   E947             CKROF1:
2524   E947 11 09 00    	LD	DE,9		;look at bit 7 of the ninth byte.
2525   E94A 19          	ADD	HL,DE
2526   E94B 7E          	LD	A,(HL)
2527   E94C 17          	RLA	
2528   E94D D0          	RET	NC		;return if ok.
2529   E94E 21 0F E4    	LD	HL,ROFILE	;else, print error message and terminate.
2530   E951 C3 4A E7    	JP	JUMPHL
TASM Z80 Assembler.               cpm22.z80                        page 48
 CP/M Ver 2.2 BDOS

2531   E954             ;
2532   E954             ;-------------------------------------------------------------
2533   E954             ;   Check the write protect status of the active disk.
2534   E954             ;
2535   E954             CHKWPRT:
2536   E954 CD 1E E9    	CALL	GETWPRT
2537   E957 C8          	RET	Z		;return if ok.
2538   E958 21 0D E4    	LD	HL,RODISK	;else print message and terminate.
2539   E95B C3 4A E7    	JP	JUMPHL
2540   E95E             ;
2541   E95E             ;-------------------------------------------------------------
2542   E95E             ;   Routine to set (HL) pointing to the proper entry in the
2543   E95E             ; directory buffer.
2544   E95E             ;
2545   E95E             FCB2HL:
2546   E95E 2A BA F1    	LD	HL,(DIRBUF)	;get address of buffer.
2547   E961 3A EA F1    	LD	A,(FCBPOS)	;relative position of file.
2548   E964             ;
2549   E964             ;-------------------------------------------------------------
2550   E964             ;   Routine to add (A) to (HL).
2551   E964             ;
2552   E964             ADDA2HL:
2553   E964 85          	ADD	A,L
2554   E965 6F          	LD	L,A
2555   E966 D0          	RET	NC
2556   E967 24          	INC	H		;take care of any carry.
2557   E968 C9          	RET	
2558   E969             ;
2559   E969             ;-------------------------------------------------------------
2560   E969             ;   Routine to get the 's2' byte from the fcb supplied in
2561   E969             ; the initial parameter specification.
2562   E969             ;
2563   E969             GETS2:
2564   E969 2A 43 E7    	LD	HL,(PARAMS)	;get address of fcb.
2565   E96C 11 0E 00    	LD	DE,14		;relative position of 's2'.
2566   E96F 19          	ADD	HL,DE
2567   E970 7E          	LD	A,(HL)		;extract this byte.
2568   E971 C9          	RET	
2569   E972             ;
2570   E972             ;-------------------------------------------------------------
2571   E972             ;   Clear the 's2' byte in the fcb.
2572   E972             ;
2573   E972             CLEARS2:
2574   E972 CD 69 E9    	CALL	GETS2		;this sets (HL) pointing to it.
2575   E975 36 00       	LD	(HL),0		;now clear it.
2576   E977 C9          	RET	
2577   E978             ;
2578   E978             ;-------------------------------------------------------------
2579   E978             ;   Set bit 7 in the 's2' byte of the fcb.
2580   E978             ;
2581   E978             SETS2B7:
2582   E978 CD 69 E9    	CALL	GETS2		;get the byte.
2583   E97B F6 80       	OR	80H		;and set bit 7.
2584   E97D 77          	LD	(HL),A		;then store.
2585   E97E C9          	RET	
2586   E97F             ;
2587   E97F             ;-------------------------------------------------------------
2588   E97F             ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2589   E97F             ; the difference. This checks to see if there are more file
TASM Z80 Assembler.               cpm22.z80                        page 49
 CP/M Ver 2.2 BDOS

2590   E97F             ; names in the directory. We are at (FILEPOS) and there are
2591   E97F             ; (SCRATCH1) of them to check.
2592   E97F             ;
2593   E97F             MOREFLS:
2594   E97F 2A EB F1    	LD	HL,(FILEPOS)	;we are here.
2595   E982 EB          	EX	DE,HL
2596   E983 2A B4 F1    	LD	HL,(SCRATCH1)	;and don't go past here.
2597   E986 7B          	LD	A,E		;compute difference but don't keep.
2598   E987 96          	SUB	(HL)
2599   E988 23          	INC	HL
2600   E989 7A          	LD	A,D
2601   E98A 9E          	SBC	A,(HL)		;set carry if no more names.
2602   E98B C9          	RET	
2603   E98C             ;
2604   E98C             ;-------------------------------------------------------------
2605   E98C             ;   Call this routine to prevent (SCRATCH1) from being greater
2606   E98C             ; than (FILEPOS).
2607   E98C             ;
2608   E98C             CHKNMBR:
2609   E98C CD 7F E9    	CALL	MOREFLS		;SCRATCH1 too big?
2610   E98F D8          	RET	C
2611   E990 13          	INC	DE		;yes, reset it to (FILEPOS).
2612   E991 72          	LD	(HL),D
2613   E992 2B          	DEC	HL
2614   E993 73          	LD	(HL),E
2615   E994 C9          	RET	
2616   E995             ;
2617   E995             ;-------------------------------------------------------------
2618   E995             ;   Compute (HL)=(DE)-(HL)
2619   E995             ;
2620   E995             SUBHL:
2621   E995 7B          	LD	A,E		;compute difference.
2622   E996 95          	SUB	L
2623   E997 6F          	LD	L,A		;store low byte.
2624   E998 7A          	LD	A,D
2625   E999 9C          	SBC	A,H
2626   E99A 67          	LD	H,A		;and then high byte.
2627   E99B C9          	RET	
2628   E99C             ;
2629   E99C             ;-------------------------------------------------------------
2630   E99C             ;   Set the directory checksum byte.
2631   E99C             ;
2632   E99C             SETDIR:
2633   E99C 0E FF       	LD	C,0FFH
2634   E99E             ;
2635   E99E             ;-------------------------------------------------------------
2636   E99E             ;   Routine to set or compare the directory checksum byte. If
2637   E99E             ; (C)=0ffh, then this will set the checksum byte. Else the byte
2638   E99E             ; will be checked. If the check fails (the disk has been changed),
2639   E99E             ; then this disk will be write protected.
2640   E99E             ;
2641   E99E             CHECKDIR:
2642   E99E 2A ED F1    	LD	HL,(CKSUMTBL)
2643   E9A1 EB          	EX	DE,HL
2644   E9A2 2A CD F1    	LD	HL,(ALLOC1)
2645   E9A5 CD 95 E9    	CALL	SUBHL
2646   E9A8 D0          	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2647   E9A9 C5          	PUSH	BC
2648   E9AA CD F7 E8    	CALL	CHECKSUM	;else compute checksum.
TASM Z80 Assembler.               cpm22.z80                        page 50
 CP/M Ver 2.2 BDOS

2649   E9AD 2A BE F1    	LD	HL,(CHKVECT)	;get address of checksum table.
2650   E9B0 EB          	EX	DE,HL
2651   E9B1 2A ED F1    	LD	HL,(CKSUMTBL)
2652   E9B4 19          	ADD	HL,DE		;set (HL) to point to byte for this drive.
2653   E9B5 C1          	POP	BC
2654   E9B6 0C          	INC	C		;set or check ?
2655   E9B7 CA C4 E9    	JP	Z,CHKDIR1
2656   E9BA BE          	CP	(HL)		;check them.
2657   E9BB C8          	RET	Z		;return if they are the same.
2658   E9BC CD 7F E9    	CALL	MOREFLS		;not the same, do we care?
2659   E9BF D0          	RET	NC
2660   E9C0 CD 2C E9    	CALL	WRTPRTD		;yes, mark this as write protected.
2661   E9C3 C9          	RET	
2662   E9C4             CHKDIR1:
2663   E9C4 77          	LD	(HL),A		;just set the byte.
2664   E9C5 C9          	RET	
2665   E9C6             ;
2666   E9C6             ;-------------------------------------------------------------
2667   E9C6             ;   Do a write to the directory of the current disk.
2668   E9C6             ;
2669   E9C6             DIRWRITE:
2670   E9C6 CD 9C E9    	CALL	SETDIR		;set checksum byte.
2671   E9C9 CD E0 E9    	CALL	DIRDMA		;set directory dma address.
2672   E9CC 0E 01       	LD	C,1		;tell the bios to actually write.
2673   E9CE CD B8 E7    	CALL	DOWRITE		;then do the write.
2674   E9D1 C3 DA E9    	JP	DEFDMA
2675   E9D4             ;
2676   E9D4             ;-------------------------------------------------------------
2677   E9D4             ;   Read from the directory.
2678   E9D4             ;
2679   E9D4             DIRREAD:
2680   E9D4 CD E0 E9    	CALL	DIRDMA		;set the directory dma address.
2681   E9D7 CD B2 E7    	CALL	DOREAD		;and read it.
2682   E9DA             ;
2683   E9DA             ;-------------------------------------------------------------
2684   E9DA             ;   Routine to set the dma address to the users choice.
2685   E9DA             ;
2686   E9DA             DEFDMA:
2687   E9DA 21 B2 F1    	LD	HL,USERDMA	;reset the default dma address and return.
2688   E9DD C3 E3 E9    	JP	DIRDMA1
2689   E9E0             ;
2690   E9E0             ;-------------------------------------------------------------
2691   E9E0             ;   Routine to set the dma address for directory work.
2692   E9E0             ;
2693   E9E0             DIRDMA:
2694   E9E0 21 BA F1    	LD	HL,DIRBUF
2695   E9E3             ;
2696   E9E3             ;-------------------------------------------------------------
2697   E9E3             ;   Set the dma address. On entry, (HL) points to
2698   E9E3             ; word containing the desired dma address.
2699   E9E3             ;
2700   E9E3             DIRDMA1:
2701   E9E3 4E          	LD	C,(HL)
2702   E9E4 23          	INC	HL
2703   E9E5 46          	LD	B,(HL)		;setup (BC) and go to the bios to set it.
2704   E9E6 C3 24 F2    	JP	SETDMA
2705   E9E9             ;
2706   E9E9             ;-------------------------------------------------------------
2707   E9E9             ;   Move the directory buffer into user's dma space.
TASM Z80 Assembler.               cpm22.z80                        page 51
 CP/M Ver 2.2 BDOS

2708   E9E9             ;
2709   E9E9             MOVEDIR:
2710   E9E9 2A BA F1    	LD	HL,(DIRBUF)	;buffer is located here, and
2711   E9EC EB          	EX	DE,HL
2712   E9ED 2A B2 F1    	LD	HL,(USERDMA)	; put it here.
2713   E9F0 0E 80       	LD	C,128		;this is its length.
2714   E9F2 C3 4F E7    	JP	DE2HL		;move it now and return.
2715   E9F5             ;
2716   E9F5             ;-------------------------------------------------------------
2717   E9F5             ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2718   E9F5             ;
2719   E9F5             CKFILPOS:
2720   E9F5 21 EB F1    	LD	HL,FILEPOS
2721   E9F8 7E          	LD	A,(HL)
2722   E9F9 23          	INC	HL
2723   E9FA BE          	CP	(HL)		;are both bytes the same?
2724   E9FB C0          	RET	NZ
2725   E9FC 3C          	INC	A		;yes, but are they each 0ffh?
2726   E9FD C9          	RET	
2727   E9FE             ;
2728   E9FE             ;-------------------------------------------------------------
2729   E9FE             ;   Set location (FILEPOS) to 0ffffh.
2730   E9FE             ;
2731   E9FE             STFILPOS:
2732   E9FE 21 FF FF    	LD	HL,0FFFFH
2733   EA01 22 EB F1    	LD	(FILEPOS),HL
2734   EA04 C9          	RET	
2735   EA05             ;
2736   EA05             ;-------------------------------------------------------------
2737   EA05             ;   Move on to the next file position within the current
2738   EA05             ; directory buffer. If no more exist, set pointer to 0ffffh
2739   EA05             ; and the calling routine will check for this. Enter with (C)
2740   EA05             ; equal to 0ffh to cause the checksum byte to be set, else we
2741   EA05             ; will check this disk and set write protect if checksums are
2742   EA05             ; not the same (applies only if another directory sector must
2743   EA05             ; be read).
2744   EA05             ;
2745   EA05             NXENTRY:
2746   EA05 2A C9 F1    	LD	HL,(DIRSIZE)	;get directory entry size limit.
2747   EA08 EB          	EX	DE,HL
2748   EA09 2A EB F1    	LD	HL,(FILEPOS)	;get current count.
2749   EA0C 23          	INC	HL		;go on to the next one.
2750   EA0D 22 EB F1    	LD	(FILEPOS),HL
2751   EA10 CD 95 E9    	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2752   EA13 D2 19 EA    	JP	NC,NXENT1	;is there more room left?
2753   EA16 C3 FE E9    	JP	STFILPOS	;no. Set this flag and return.
2754   EA19             NXENT1:
2755   EA19 3A EB F1    	LD	A,(FILEPOS)	;get file position within directory.
2756   EA1C E6 03       	AND	03H		;only look within this sector (only 4 entries fit).
2757   EA1E 06 05       	LD	B,5		;convert to relative position (32 bytes each).
2758   EA20             NXENT2:
2759   EA20 87          	ADD	A,A		;note that this is not efficient code.
2760   EA21 05          	DEC	B		;5 'ADD A's would be better.
2761   EA22 C2 20 EA    	JP	NZ,NXENT2
2762   EA25 32 EA F1    	LD	(FCBPOS),A	;save it as position of fcb.
2763   EA28 B7          	OR	A
2764   EA29 C0          	RET	NZ		;return if we are within buffer.
2765   EA2A C5          	PUSH	BC
2766   EA2B CD C3 E7    	CALL	TRKSEC		;we need the next directory sector.
TASM Z80 Assembler.               cpm22.z80                        page 52
 CP/M Ver 2.2 BDOS

2767   EA2E CD D4 E9    	CALL	DIRREAD
2768   EA31 C1          	POP	BC
2769   EA32 C3 9E E9    	JP	CHECKDIR
2770   EA35             ;
2771   EA35             ;-------------------------------------------------------------
2772   EA35             ;   Routine to to get a bit from the disk space allocation
2773   EA35             ; map. It is returned in (A), bit position 0. On entry to here,
2774   EA35             ; set (BC) to the block number on the disk to check.
2775   EA35             ; On return, (D) will contain the original bit position for
2776   EA35             ; this block number and (HL) will point to the address for it.
2777   EA35             ;
2778   EA35             CKBITMAP:
2779   EA35 79          	LD	A,C		;determine bit number of interest.
2780   EA36 E6 07       	AND	07H		;compute (D)=(E)=(C and 7)+1.
2781   EA38 3C          	INC	A
2782   EA39 5F          	LD	E,A		;save particular bit number.
2783   EA3A 57          	LD	D,A
2784   EA3B             ;
2785   EA3B             ;   compute (BC)=(BC)/8.
2786   EA3B             ;
2787   EA3B 79          	LD	A,C
2788   EA3C 0F          	RRCA			;now shift right 3 bits.
2789   EA3D 0F          	RRCA	
2790   EA3E 0F          	RRCA	
2791   EA3F E6 1F       	AND	1FH		;and clear bits 7,6,5.
2792   EA41 4F          	LD	C,A
2793   EA42 78          	LD	A,B
2794   EA43 87          	ADD	A,A		;now shift (B) into bits 7,6,5.
2795   EA44 87          	ADD	A,A
2796   EA45 87          	ADD	A,A
2797   EA46 87          	ADD	A,A
2798   EA47 87          	ADD	A,A
2799   EA48 B1          	OR	C		;and add in (C).
2800   EA49 4F          	LD	C,A		;ok, (C) ha been completed.
2801   EA4A 78          	LD	A,B		;is there a better way of doing this?
2802   EA4B 0F          	RRCA	
2803   EA4C 0F          	RRCA	
2804   EA4D 0F          	RRCA	
2805   EA4E E6 1F       	AND	1FH
2806   EA50 47          	LD	B,A		;and now (B) is completed.
2807   EA51             ;
2808   EA51             ;   use this as an offset into the disk space allocation
2809   EA51             ; table.
2810   EA51             ;
2811   EA51 2A C0 F1    	LD	HL,(ALOCVECT)
2812   EA54 09          	ADD	HL,BC
2813   EA55 7E          	LD	A,(HL)		;now get correct byte.
2814   EA56             CKBMAP1:
2815   EA56 07          	RLCA			;get correct bit into position 0.
2816   EA57 1D          	DEC	E
2817   EA58 C2 56 EA    	JP	NZ,CKBMAP1
2818   EA5B C9          	RET	
2819   EA5C             ;
2820   EA5C             ;-------------------------------------------------------------
2821   EA5C             ;   Set or clear the bit map such that block number (BC) will be marked
2822   EA5C             ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2823   EA5C             ; 1 then it will be set (don't use anyother values).
2824   EA5C             ;
2825   EA5C             STBITMAP:
TASM Z80 Assembler.               cpm22.z80                        page 53
 CP/M Ver 2.2 BDOS

2826   EA5C D5          	PUSH	DE
2827   EA5D CD 35 EA    	CALL	CKBITMAP	;get the byte of interest.
2828   EA60 E6 FE       	AND	0FEH		;clear the affected bit.
2829   EA62 C1          	POP	BC
2830   EA63 B1          	OR	C		;and now set it acording to (C).
2831   EA64             ;
2832   EA64             ;-------------------------------------------------------------
2833   EA64             ;  entry to restore the original bit position and then store
2834   EA64             ; in table. (A) contains the value, (D) contains the bit
2835   EA64             ; position (1-8), and (HL) points to the address within the
2836   EA64             ; space allocation table for this byte.
2837   EA64             ;
2838   EA64             STBMAP1:
2839   EA64 0F          	RRCA			;restore original bit position.
2840   EA65 15          	DEC	D
2841   EA66 C2 64 EA    	JP	NZ,STBMAP1
2842   EA69 77          	LD	(HL),A		;and stor byte in table.
2843   EA6A C9          	RET	
2844   EA6B             ;
2845   EA6B             ;-------------------------------------------------------------
2846   EA6B             ;   Set/clear space used bits in allocation map for this file.
2847   EA6B             ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2848   EA6B             ;
2849   EA6B             SETFILE:
2850   EA6B CD 5E E9    	CALL	FCB2HL		;get address of fcb
2851   EA6E 11 10 00    	LD	DE,16
2852   EA71 19          	ADD	HL,DE		;get to block number bytes.
2853   EA72 C5          	PUSH	BC
2854   EA73 0E 11       	LD	C,17		;check all 17 bytes (max) of table.
2855   EA75             SETFL1:
2856   EA75 D1          	POP	DE
2857   EA76 0D          	DEC	C		;done all bytes yet?
2858   EA77 C8          	RET	Z
2859   EA78 D5          	PUSH	DE
2860   EA79 3A DE F1    	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
2861   EA7C B7          	OR	A
2862   EA7D CA 88 EA    	JP	Z,SETFL2
2863   EA80 C5          	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
2864   EA81 E5          	PUSH	HL
2865   EA82 4E          	LD	C,(HL)		;get low byte from table, always
2866   EA83 06 00       	LD	B,0		;set high byte to zero.
2867   EA85 C3 8E EA    	JP	SETFL3
2868   EA88             SETFL2:
2869   EA88 0D          	DEC	C		;for 16 bit block numbers, adjust counter.
2870   EA89 C5          	PUSH	BC
2871   EA8A 4E          	LD	C,(HL)		;now get both the low and high bytes.
2872   EA8B 23          	INC	HL
2873   EA8C 46          	LD	B,(HL)
2874   EA8D E5          	PUSH	HL
2875   EA8E             SETFL3:
2876   EA8E 79          	LD	A,C		;block used?
2877   EA8F B0          	OR	B
2878   EA90 CA 9D EA    	JP	Z,SETFL4
2879   EA93 2A C7 F1    	LD	HL,(DSKSIZE)	;is this block number within the
2880   EA96 7D          	LD	A,L		;space on the disk?
2881   EA97 91          	SUB	C
2882   EA98 7C          	LD	A,H
2883   EA99 98          	SBC	A,B
2884   EA9A D4 5C EA    	CALL	NC,STBITMAP	;yes, set the proper bit.
TASM Z80 Assembler.               cpm22.z80                        page 54
 CP/M Ver 2.2 BDOS

2885   EA9D             SETFL4:
2886   EA9D E1          	POP	HL		;point to next block number in fcb.
2887   EA9E 23          	INC	HL
2888   EA9F C1          	POP	BC
2889   EAA0 C3 75 EA    	JP	SETFL1
2890   EAA3             ;
2891   EAA3             ;-------------------------------------------------------------
2892   EAA3             ;   Construct the space used allocation bit map for the active
2893   EAA3             ; drive. If a file name starts with '$' and it is under the
2894   EAA3             ; current user number, then (STATUS) is set to minus 1. Otherwise
2895   EAA3             ; it is not set at all.
2896   EAA3             ;
2897   EAA3             BITMAP:
2898   EAA3 2A C7 F1    	LD	HL,(DSKSIZE)	;compute size of allocation table.
2899   EAA6 0E 03       	LD	C,3
2900   EAA8 CD EA E8    	CALL	SHIFTR		;(HL)=(HL)/8.
2901   EAAB 23          	INC	HL		;at lease 1 byte.
2902   EAAC 44          	LD	B,H
2903   EAAD 4D          	LD	C,L		;set (BC) to the allocation table length.
2904   EAAE             ;
2905   EAAE             ;   Initialize the bitmap for this drive. Right now, the first
2906   EAAE             ; two bytes are specified by the disk parameter block. However
2907   EAAE             ; a patch could be entered here if it were necessary to setup
2908   EAAE             ; this table in a special mannor. For example, the bios could
2909   EAAE             ; determine locations of 'bad blocks' and set them as already
2910   EAAE             ; 'used' in the map.
2911   EAAE             ;
2912   EAAE 2A C0 F1    	LD	HL,(ALOCVECT)	;now zero out the table now.
2913   EAB1             BITMAP1:
2914   EAB1 36 00       	LD	(HL),0
2915   EAB3 23          	INC	HL
2916   EAB4 0B          	DEC	BC
2917   EAB5 78          	LD	A,B
2918   EAB6 B1          	OR	C
2919   EAB7 C2 B1 EA    	JP	NZ,BITMAP1
2920   EABA 2A CB F1    	LD	HL,(ALLOC0)	;get initial space used by directory.
2921   EABD EB          	EX	DE,HL
2922   EABE 2A C0 F1    	LD	HL,(ALOCVECT)	;and put this into map.
2923   EAC1 73          	LD	(HL),E
2924   EAC2 23          	INC	HL
2925   EAC3 72          	LD	(HL),D
2926   EAC4             ;
2927   EAC4             ;   End of initialization portion.
2928   EAC4             ;
2929   EAC4 CD A1 E7    	CALL	HOMEDRV		;now home the drive.
2930   EAC7 2A B4 F1    	LD	HL,(SCRATCH1)
2931   EACA 36 03       	LD	(HL),3		;force next directory request to read
2932   EACC 23          	INC	HL		;in a sector.
2933   EACD 36 00       	LD	(HL),0
2934   EACF CD FE E9    	CALL	STFILPOS	;clear initial file position also.
2935   EAD2             BITMAP2:
2936   EAD2 0E FF       	LD	C,0FFH		;read next file name in directory
2937   EAD4 CD 05 EA    	CALL	NXENTRY		;and set checksum byte.
2938   EAD7 CD F5 E9    	CALL	CKFILPOS	;is there another file?
2939   EADA C8          	RET	Z
2940   EADB CD 5E E9    	CALL	FCB2HL		;yes, get its address.
2941   EADE 3E E5       	LD	A,0E5H
2942   EAE0 BE          	CP	(HL)		;empty file entry?
2943   EAE1 CA D2 EA    	JP	Z,BITMAP2
TASM Z80 Assembler.               cpm22.z80                        page 55
 CP/M Ver 2.2 BDOS

2944   EAE4 3A 41 E7    	LD	A,(USERNO)	;no, correct user number?
2945   EAE7 BE          	CP	(HL)
2946   EAE8 C2 F6 EA    	JP	NZ,BITMAP3
2947   EAEB 23          	INC	HL
2948   EAEC 7E          	LD	A,(HL)		;yes, does name start with a '$'?
2949   EAED D6 24       	SUB	'$'
2950   EAEF C2 F6 EA    	JP	NZ,BITMAP3
2951   EAF2 3D          	DEC	A		;yes, set atatus to minus one.
2952   EAF3 32 45 E7    	LD	(STATUS),A
2953   EAF6             BITMAP3:
2954   EAF6 0E 01       	LD	C,1		;now set this file's space as used in bit map.
2955   EAF8 CD 6B EA    	CALL	SETFILE
2956   EAFB CD 8C E9    	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
2957   EAFE C3 D2 EA    	JP	BITMAP2
2958   EB01             ;
2959   EB01             ;   Set the status (STATUS) and return.
2960   EB01             ;
2961   EB01             STSTATUS:
2962   EB01 3A D5 F1    	LD	A,(FNDSTAT)
2963   EB04 C3 01 E7    	JP	SETSTAT
2964   EB07             ;
2965   EB07             ;   Check extents in (A) and (C). Set the zero flag if they
2966   EB07             ; are the same. The number of 16k chunks of disk space that
2967   EB07             ; the directory extent covers is expressad is (EXTMASK+1).
2968   EB07             ; No registers are modified.
2969   EB07             ;
2970   EB07             SAMEXT:
2971   EB07 C5          	PUSH	BC
2972   EB08 F5          	PUSH	AF
2973   EB09 3A C6 F1    	LD	A,(EXTMASK)	;get extent mask and use it to
2974   EB0C 2F          	CPL			;to compare both extent numbers.
2975   EB0D 47          	LD	B,A		;save resulting mask here.
2976   EB0E 79          	LD	A,C		;mask first extent and save in (C).
2977   EB0F A0          	AND	B
2978   EB10 4F          	LD	C,A
2979   EB11 F1          	POP	AF		;now mask second extent and compare
2980   EB12 A0          	AND	B		;with the first one.
2981   EB13 91          	SUB	C
2982   EB14 E6 1F       	AND	1FH		;(* only check buts 0-4 *)
2983   EB16 C1          	POP	BC		;the zero flag is set if they are the same.
2984   EB17 C9          	RET			;restore (BC) and return.
2985   EB18             ;
2986   EB18             ;-------------------------------------------------------------
2987   EB18             ;   Search for the first occurence of a file name. On entry,
2988   EB18             ; register (C) should contain the number of bytes of the fcb
2989   EB18             ; that must match.
2990   EB18             ;
2991   EB18             FINDFST:
2992   EB18 3E FF       	LD	A,0FFH
2993   EB1A 32 D5 F1    	LD	(FNDSTAT),A
2994   EB1D 21 D9 F1    	LD	HL,COUNTER	;save character count.
2995   EB20 71          	LD	(HL),C
2996   EB21 2A 43 E7    	LD	HL,(PARAMS)	;get filename to match.
2997   EB24 22 DA F1    	LD	(SAVEFCB),HL	;and save.
2998   EB27 CD FE E9    	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
2999   EB2A CD A1 E7    	CALL	HOMEDRV		;home the drive.
3000   EB2D             ;
3001   EB2D             ;-------------------------------------------------------------
3002   EB2D             ;   Entry to locate the next occurence of a filename within the
TASM Z80 Assembler.               cpm22.z80                        page 56
 CP/M Ver 2.2 BDOS

3003   EB2D             ; directory. The disk is not expected to have been changed. If
3004   EB2D             ; it was, then it will be write protected.
3005   EB2D             ;
3006   EB2D             FINDNXT:
3007   EB2D 0E 00       	LD	C,0		;write protect the disk if changed.
3008   EB2F CD 05 EA    	CALL	NXENTRY		;get next filename entry in directory.
3009   EB32 CD F5 E9    	CALL	CKFILPOS	;is file position = 0ffffh?
3010   EB35 CA 94 EB    	JP	Z,FNDNXT6	;yes, exit now then.
3011   EB38 2A DA F1    	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
3012   EB3B EB          	EX	DE,HL
3013   EB3C 1A          	LD	A,(DE)
3014   EB3D FE E5       	CP	0E5H		;empty directory entry?
3015   EB3F CA 4A EB    	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
3016   EB42 D5          	PUSH	DE
3017   EB43 CD 7F E9    	CALL	MOREFLS		;more files in directory?
3018   EB46 D1          	POP	DE
3019   EB47 D2 94 EB    	JP	NC,FNDNXT6	;no more. Exit now.
3020   EB4A             FNDNXT1:
3021   EB4A CD 5E E9    	CALL	FCB2HL		;get address of this fcb in directory.
3022   EB4D 3A D9 F1    	LD	A,(COUNTER)	;get number of bytes (characters) to check.
3023   EB50 4F          	LD	C,A
3024   EB51 06 00       	LD	B,0		;initialize byte position counter.
3025   EB53             FNDNXT2:
3026   EB53 79          	LD	A,C		;are we done with the compare?
3027   EB54 B7          	OR	A
3028   EB55 CA 83 EB    	JP	Z,FNDNXT5
3029   EB58 1A          	LD	A,(DE)		;no, check next byte.
3030   EB59 FE 3F       	CP	'?'		;don't care about this character?
3031   EB5B CA 7C EB    	JP	Z,FNDNXT4
3032   EB5E 78          	LD	A,B		;get bytes position in fcb.
3033   EB5F FE 0D       	CP	13		;don't care about the thirteenth byte either.
3034   EB61 CA 7C EB    	JP	Z,FNDNXT4
3035   EB64 FE 0C       	CP	12		;extent byte?
3036   EB66 1A          	LD	A,(DE)
3037   EB67 CA 73 EB    	JP	Z,FNDNXT3
3038   EB6A 96          	SUB	(HL)		;otherwise compare characters.
3039   EB6B E6 7F       	AND	7FH
3040   EB6D C2 2D EB    	JP	NZ,FINDNXT	;not the same, check next entry.
3041   EB70 C3 7C EB    	JP	FNDNXT4		;so far so good, keep checking.
3042   EB73             FNDNXT3:
3043   EB73 C5          	PUSH	BC		;check the extent byte here.
3044   EB74 4E          	LD	C,(HL)
3045   EB75 CD 07 EB    	CALL	SAMEXT
3046   EB78 C1          	POP	BC
3047   EB79 C2 2D EB    	JP	NZ,FINDNXT	;not the same, look some more.
3048   EB7C             ;
3049   EB7C             ;   So far the names compare. Bump pointers to the next byte
3050   EB7C             ; and continue until all (C) characters have been checked.
3051   EB7C             ;
3052   EB7C             FNDNXT4:
3053   EB7C 13          	INC	DE		;bump pointers.
3054   EB7D 23          	INC	HL
3055   EB7E 04          	INC	B
3056   EB7F 0D          	DEC	C		;adjust character counter.
3057   EB80 C3 53 EB    	JP	FNDNXT2
3058   EB83             FNDNXT5:
3059   EB83 3A EB F1    	LD	A,(FILEPOS)	;return the position of this entry.
3060   EB86 E6 03       	AND	03H
3061   EB88 32 45 E7    	LD	(STATUS),A
TASM Z80 Assembler.               cpm22.z80                        page 57
 CP/M Ver 2.2 BDOS

3062   EB8B 21 D5 F1    	LD	HL,FNDSTAT
3063   EB8E 7E          	LD	A,(HL)
3064   EB8F 17          	RLA	
3065   EB90 D0          	RET	NC
3066   EB91 AF          	XOR	A
3067   EB92 77          	LD	(HL),A
3068   EB93 C9          	RET	
3069   EB94             ;
3070   EB94             ;   Filename was not found. Set appropriate status.
3071   EB94             ;
3072   EB94             FNDNXT6:
3073   EB94 CD FE E9    	CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
3074   EB97 3E FF       	LD	A,0FFH		;say not located.
3075   EB99 C3 01 E7    	JP	SETSTAT
3076   EB9C             ;
3077   EB9C             ;-------------------------------------------------------------
3078   EB9C             ;   Erase files from the directory. Only the first byte of the
3079   EB9C             ; fcb will be affected. It is set to (E5).
3080   EB9C             ;
3081   EB9C             ERAFILE:
3082   EB9C CD 54 E9    	CALL	CHKWPRT		;is disk write protected?
3083   EB9F 0E 0C       	LD	C,12		;only compare file names.
3084   EBA1 CD 18 EB    	CALL	FINDFST		;get first file name.
3085   EBA4             ERAFIL1:
3086   EBA4 CD F5 E9    	CALL	CKFILPOS	;any found?
3087   EBA7 C8          	RET	Z		;nope, we must be done.
3088   EBA8 CD 44 E9    	CALL	CHKROFL		;is file read only?
3089   EBAB CD 5E E9    	CALL	FCB2HL		;nope, get address of fcb and
3090   EBAE 36 E5       	LD	(HL),0E5H	;set first byte to 'empty'.
3091   EBB0 0E 00       	LD	C,0		;clear the space from the bit map.
3092   EBB2 CD 6B EA    	CALL	SETFILE
3093   EBB5 CD C6 E9    	CALL	DIRWRITE	;now write the directory sector back out.
3094   EBB8 CD 2D EB    	CALL	FINDNXT		;find the next file name.
3095   EBBB C3 A4 EB    	JP	ERAFIL1		;and repeat process.
3096   EBBE             ;
3097   EBBE             ;-------------------------------------------------------------
3098   EBBE             ;   Look through the space allocation map (bit map) for the
3099   EBBE             ; next available block. Start searching at block number (BC-1).
3100   EBBE             ; The search procedure is to look for an empty block that is
3101   EBBE             ; before the starting block. If not empty, look at a later
3102   EBBE             ; block number. In this way, we return the closest empty block
3103   EBBE             ; on either side of the 'target' block number. This will speed
3104   EBBE             ; access on random devices. For serial devices, this should be
3105   EBBE             ; changed to look in the forward direction first and then start
3106   EBBE             ; at the front and search some more.
3107   EBBE             ;
3108   EBBE             ;   On return, (DE)= block number that is empty and (HL) =0
3109   EBBE             ; if no empry block was found.
3110   EBBE             ;
3111   EBBE             FNDSPACE:
3112   EBBE 50          	LD	D,B		;set (DE) as the block that is checked.
3113   EBBF 59          	LD	E,C
3114   EBC0             ;
3115   EBC0             ;   Look before target block. Registers (BC) are used as the lower
3116   EBC0             ; pointer and (DE) as the upper pointer.
3117   EBC0             ;
3118   EBC0             FNDSPA1:
3119   EBC0 79          	LD	A,C		;is block 0 specified?
3120   EBC1 B0          	OR	B
TASM Z80 Assembler.               cpm22.z80                        page 58
 CP/M Ver 2.2 BDOS

3121   EBC2 CA D1 EB    	JP	Z,FNDSPA2
3122   EBC5 0B          	DEC	BC		;nope, check previous block.
3123   EBC6 D5          	PUSH	DE
3124   EBC7 C5          	PUSH	BC
3125   EBC8 CD 35 EA    	CALL	CKBITMAP
3126   EBCB 1F          	RRA			;is this block empty?
3127   EBCC D2 EC EB    	JP	NC,FNDSPA3	;yes. use this.
3128   EBCF             ;
3129   EBCF             ;   Note that the above logic gets the first block that it finds
3130   EBCF             ; that is empty. Thus a file could be written 'backward' making
3131   EBCF             ; it very slow to access. This could be changed to look for the
3132   EBCF             ; first empty block and then continue until the start of this
3133   EBCF             ; empty space is located and then used that starting block.
3134   EBCF             ; This should help speed up access to some files especially on
3135   EBCF             ; a well used disk with lots of fairly small 'holes'.
3136   EBCF             ;
3137   EBCF C1          	POP	BC		;nope, check some more.
3138   EBD0 D1          	POP	DE
3139   EBD1             ;
3140   EBD1             ;   Now look after target block.
3141   EBD1             ;
3142   EBD1             FNDSPA2:
3143   EBD1 2A C7 F1    	LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
3144   EBD4 7B          	LD	A,E
3145   EBD5 95          	SUB	L
3146   EBD6 7A          	LD	A,D
3147   EBD7 9C          	SBC	A,H
3148   EBD8 D2 F4 EB    	JP	NC,FNDSPA4
3149   EBDB 13          	INC	DE		;yes, move on to next one.
3150   EBDC C5          	PUSH	BC
3151   EBDD D5          	PUSH	DE
3152   EBDE 42          	LD	B,D
3153   EBDF 4B          	LD	C,E
3154   EBE0 CD 35 EA    	CALL	CKBITMAP	;check it.
3155   EBE3 1F          	RRA			;empty?
3156   EBE4 D2 EC EB    	JP	NC,FNDSPA3
3157   EBE7 D1          	POP	DE		;nope, continue searching.
3158   EBE8 C1          	POP	BC
3159   EBE9 C3 C0 EB    	JP	FNDSPA1
3160   EBEC             ;
3161   EBEC             ;   Empty block found. Set it as used and return with (HL)
3162   EBEC             ; pointing to it (true?).
3163   EBEC             ;
3164   EBEC             FNDSPA3:
3165   EBEC 17          	RLA			;reset byte.
3166   EBED 3C          	INC	A		;and set bit 0.
3167   EBEE CD 64 EA    	CALL	STBMAP1		;update bit map.
3168   EBF1 E1          	POP	HL		;set return registers.
3169   EBF2 D1          	POP	DE
3170   EBF3 C9          	RET	
3171   EBF4             ;
3172   EBF4             ;   Free block was not found. If (BC) is not zero, then we have
3173   EBF4             ; not checked all of the disk space.
3174   EBF4             ;
3175   EBF4             FNDSPA4:
3176   EBF4 79          	LD	A,C
3177   EBF5 B0          	OR	B
3178   EBF6 C2 C0 EB    	JP	NZ,FNDSPA1
3179   EBF9 21 00 00    	LD	HL,0		;set 'not found' status.
TASM Z80 Assembler.               cpm22.z80                        page 59
 CP/M Ver 2.2 BDOS

3180   EBFC C9          	RET	
3181   EBFD             ;
3182   EBFD             ;-------------------------------------------------------------
3183   EBFD             ;   Move a complete fcb entry into the directory and write it.
3184   EBFD             ;
3185   EBFD             FCBSET:
3186   EBFD 0E 00       	LD	C,0
3187   EBFF 1E 20       	LD	E,32		;length of each entry.
3188   EC01             ;
3189   EC01             ;-------------------------------------------------------------
3190   EC01             ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
3191   EC01             ; fcb in directory starting at relative byte (C). This updated
3192   EC01             ; directory buffer is then written to the disk.
3193   EC01             ;
3194   EC01             UPDATE:
3195   EC01 D5          	PUSH	DE
3196   EC02 06 00       	LD	B,0		;set (BC) to relative byte position.
3197   EC04 2A 43 E7    	LD	HL,(PARAMS)	;get address of fcb.
3198   EC07 09          	ADD	HL,BC		;compute starting byte.
3199   EC08 EB          	EX	DE,HL
3200   EC09 CD 5E E9    	CALL	FCB2HL		;get address of fcb to update in directory.
3201   EC0C C1          	POP	BC		;set (C) to number of bytes to change.
3202   EC0D CD 4F E7    	CALL	DE2HL
3203   EC10             UPDATE1:
3204   EC10 CD C3 E7    	CALL	TRKSEC		;determine the track and sector affected.
3205   EC13 C3 C6 E9    	JP	DIRWRITE	;then write this sector out.
3206   EC16             ;
3207   EC16             ;-------------------------------------------------------------
3208   EC16             ;   Routine to change the name of all files on the disk with a
3209   EC16             ; specified name. The fcb contains the current name as the
3210   EC16             ; first 12 characters and the new name 16 bytes into the fcb.
3211   EC16             ;
3212   EC16             CHGNAMES:
3213   EC16 CD 54 E9    	CALL	CHKWPRT		;check for a write protected disk.
3214   EC19 0E 0C       	LD	C,12		;match first 12 bytes of fcb only.
3215   EC1B CD 18 EB    	CALL	FINDFST		;get first name.
3216   EC1E 2A 43 E7    	LD	HL,(PARAMS)	;get address of fcb.
3217   EC21 7E          	LD	A,(HL)		;get user number.
3218   EC22 11 10 00    	LD	DE,16		;move over to desired name.
3219   EC25 19          	ADD	HL,DE
3220   EC26 77          	LD	(HL),A		;keep same user number.
3221   EC27             CHGNAM1:
3222   EC27 CD F5 E9    	CALL	CKFILPOS	;any matching file found?
3223   EC2A C8          	RET	Z		;no, we must be done.
3224   EC2B CD 44 E9    	CALL	CHKROFL		;check for read only file.
3225   EC2E 0E 10       	LD	C,16		;start 16 bytes into fcb.
3226   EC30 1E 0C       	LD	E,12		;and update the first 12 bytes of directory.
3227   EC32 CD 01 EC    	CALL	UPDATE
3228   EC35 CD 2D EB    	CALL	FINDNXT		;get te next file name.
3229   EC38 C3 27 EC    	JP	CHGNAM1		;and continue.
3230   EC3B             ;
3231   EC3B             ;-------------------------------------------------------------
3232   EC3B             ;   Update a files attributes. The procedure is to search for
3233   EC3B             ; every file with the same name as shown in fcb (ignoring bit 7)
3234   EC3B             ; and then to update it (which includes bit 7). No other changes
3235   EC3B             ; are made.
3236   EC3B             ;
3237   EC3B             SAVEATTR:
3238   EC3B 0E 0C       	LD	C,12		;match first 12 bytes.
TASM Z80 Assembler.               cpm22.z80                        page 60
 CP/M Ver 2.2 BDOS

3239   EC3D CD 18 EB    	CALL	FINDFST		;look for first filename.
3240   EC40             SAVATR1:
3241   EC40 CD F5 E9    	CALL	CKFILPOS	;was one found?
3242   EC43 C8          	RET	Z		;nope, we must be done.
3243   EC44 0E 00       	LD	C,0		;yes, update the first 12 bytes now.
3244   EC46 1E 0C       	LD	E,12
3245   EC48 CD 01 EC    	CALL	UPDATE		;update filename and write directory.
3246   EC4B CD 2D EB    	CALL	FINDNXT		;and get the next file.
3247   EC4E C3 40 EC    	JP	SAVATR1		;then continue until done.
3248   EC51             ;
3249   EC51             ;-------------------------------------------------------------
3250   EC51             ;  Open a file (name specified in fcb).
3251   EC51             ;
3252   EC51             OPENIT:
3253   EC51 0E 0F       	LD	C,15		;compare the first 15 bytes.
3254   EC53 CD 18 EB    	CALL	FINDFST		;get the first one in directory.
3255   EC56 CD F5 E9    	CALL	CKFILPOS	;any at all?
3256   EC59 C8          	RET	Z
3257   EC5A             OPENIT1:
3258   EC5A CD A6 E8    	CALL	SETEXT		;point to extent byte within users fcb.
3259   EC5D 7E          	LD	A,(HL)		;and get it.
3260   EC5E F5          	PUSH	AF		;save it and address.
3261   EC5F E5          	PUSH	HL
3262   EC60 CD 5E E9    	CALL	FCB2HL		;point to fcb in directory.
3263   EC63 EB          	EX	DE,HL
3264   EC64 2A 43 E7    	LD	HL,(PARAMS)	;this is the users copy.
3265   EC67 0E 20       	LD	C,32		;move it into users space.
3266   EC69 D5          	PUSH	DE
3267   EC6A CD 4F E7    	CALL	DE2HL
3268   EC6D CD 78 E9    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
3269   EC70 D1          	POP	DE		;now get the extent byte from this fcb.
3270   EC71 21 0C 00    	LD	HL,12
3271   EC74 19          	ADD	HL,DE
3272   EC75 4E          	LD	C,(HL)		;into (C).
3273   EC76 21 0F 00    	LD	HL,15		;now get the record count byte into (B).
3274   EC79 19          	ADD	HL,DE
3275   EC7A 46          	LD	B,(HL)
3276   EC7B E1          	POP	HL		;keep the same extent as the user had originally.
3277   EC7C F1          	POP	AF
3278   EC7D 77          	LD	(HL),A
3279   EC7E 79          	LD	A,C		;is it the same as in the directory fcb?
3280   EC7F BE          	CP	(HL)
3281   EC80 78          	LD	A,B		;if yes, then use the same record count.
3282   EC81 CA 8B EC    	JP	Z,OPENIT2
3283   EC84 3E 00       	LD	A,0		;if the user specified an extent greater than
3284   EC86 DA 8B EC    	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
3285   EC89 3E 80       	LD	A,128		;otherwise set to maximum.
3286   EC8B             OPENIT2:
3287   EC8B 2A 43 E7    	LD	HL,(PARAMS)	;set record count in users fcb to (A).
3288   EC8E 11 0F 00    	LD	DE,15
3289   EC91 19          	ADD	HL,DE		;compute relative position.
3290   EC92 77          	LD	(HL),A		;and set the record count.
3291   EC93 C9          	RET	
3292   EC94             ;
3293   EC94             ;-------------------------------------------------------------
3294   EC94             ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3295   EC94             ; point to a zero value (16 bit).
3296   EC94             ;   Return with zero flag set it (DE) was moved. Registers (DE)
3297   EC94             ; and (HL) are not changed. However (A) is.
TASM Z80 Assembler.               cpm22.z80                        page 61
 CP/M Ver 2.2 BDOS

3298   EC94             ;
3299   EC94             MOVEWORD:
3300   EC94 7E          	LD	A,(HL)		;check for a zero word.
3301   EC95 23          	INC	HL
3302   EC96 B6          	OR	(HL)		;both bytes zero?
3303   EC97 2B          	DEC	HL
3304   EC98 C0          	RET	NZ		;nope, just return.
3305   EC99 1A          	LD	A,(DE)		;yes, move two bytes from (DE) into
3306   EC9A 77          	LD	(HL),A		;this zero space.
3307   EC9B 13          	INC	DE
3308   EC9C 23          	INC	HL
3309   EC9D 1A          	LD	A,(DE)
3310   EC9E 77          	LD	(HL),A
3311   EC9F 1B          	DEC	DE		;don't disturb these registers.
3312   ECA0 2B          	DEC	HL
3313   ECA1 C9          	RET	
3314   ECA2             ;
3315   ECA2             ;-------------------------------------------------------------
3316   ECA2             ;   Get here to close a file specified by (fcb).
3317   ECA2             ;
3318   ECA2             CLOSEIT:
3319   ECA2 AF          	XOR	A		;clear status and file position bytes.
3320   ECA3 32 45 E7    	LD	(STATUS),A
3321   ECA6 32 EB F1    	LD	(FILEPOS),A
3322   ECA9 32 EC F1    	LD	(FILEPOS+1),A
3323   ECAC CD 1E E9    	CALL	GETWPRT		;get write protect bit for this drive.
3324   ECAF C0          	RET	NZ		;just return if it is set.
3325   ECB0 CD 69 E9    	CALL	GETS2		;else get the 's2' byte.
3326   ECB3 E6 80       	AND	80H		;and look at bit 7 (file unmodified?).
3327   ECB5 C0          	RET	NZ		;just return if set.
3328   ECB6 0E 0F       	LD	C,15		;else look up this file in directory.
3329   ECB8 CD 18 EB    	CALL	FINDFST
3330   ECBB CD F5 E9    	CALL	CKFILPOS	;was it found?
3331   ECBE C8          	RET	Z		;just return if not.
3332   ECBF 01 10 00    	LD	BC,16		;set (HL) pointing to records used section.
3333   ECC2 CD 5E E9    	CALL	FCB2HL
3334   ECC5 09          	ADD	HL,BC
3335   ECC6 EB          	EX	DE,HL
3336   ECC7 2A 43 E7    	LD	HL,(PARAMS)	;do the same for users specified fcb.
3337   ECCA 09          	ADD	HL,BC
3338   ECCB 0E 10       	LD	C,16		;this many bytes are present in this extent.
3339   ECCD             CLOSEIT1:
3340   ECCD 3A DE F1    	LD	A,(BIGDISK)	;8 or 16 bit record numbers?
3341   ECD0 B7          	OR	A
3342   ECD1 CA E8 EC    	JP	Z,CLOSEIT4
3343   ECD4 7E          	LD	A,(HL)		;just 8 bit. Get one from users fcb.
3344   ECD5 B7          	OR	A
3345   ECD6 1A          	LD	A,(DE)		;now get one from directory fcb.
3346   ECD7 C2 DB EC    	JP	NZ,CLOSEIT2
3347   ECDA 77          	LD	(HL),A		;users byte was zero. Update from directory.
3348   ECDB             CLOSEIT2:
3349   ECDB B7          	OR	A
3350   ECDC C2 E1 EC    	JP	NZ,CLOSEIT3
3351   ECDF 7E          	LD	A,(HL)		;directories byte was zero, update from users fcb.
3352   ECE0 12          	LD	(DE),A
3353   ECE1             CLOSEIT3:
3354   ECE1 BE          	CP	(HL)		;if neither one of these bytes were zero,
3355   ECE2 C2 1F ED    	JP	NZ,CLOSEIT7	;then close error if they are not the same.
3356   ECE5 C3 FD EC    	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
TASM Z80 Assembler.               cpm22.z80                        page 62
 CP/M Ver 2.2 BDOS

3357   ECE8             CLOSEIT4:
3358   ECE8 CD 94 EC    	CALL	MOVEWORD	;update users fcb if it is zero.
3359   ECEB EB          	EX	DE,HL
3360   ECEC CD 94 EC    	CALL	MOVEWORD	;update directories fcb if it is zero.
3361   ECEF EB          	EX	DE,HL
3362   ECF0 1A          	LD	A,(DE)		;if these two values are no different,
3363   ECF1 BE          	CP	(HL)		;then a close error occured.
3364   ECF2 C2 1F ED    	JP	NZ,CLOSEIT7
3365   ECF5 13          	INC	DE		;check second byte.
3366   ECF6 23          	INC	HL
3367   ECF7 1A          	LD	A,(DE)
3368   ECF8 BE          	CP	(HL)
3369   ECF9 C2 1F ED    	JP	NZ,CLOSEIT7
3370   ECFC 0D          	DEC	C		;remember 16 bit values.
3371   ECFD             CLOSEIT5:
3372   ECFD 13          	INC	DE		;bump to next item in table.
3373   ECFE 23          	INC	HL
3374   ECFF 0D          	DEC	C		;there are 16 entries only.
3375   ED00 C2 CD EC    	JP	NZ,CLOSEIT1	;continue if more to do.
3376   ED03 01 EC FF    	LD	BC,0FFECH	;backup 20 places (extent byte).
3377   ED06 09          	ADD	HL,BC
3378   ED07 EB          	EX	DE,HL
3379   ED08 09          	ADD	HL,BC
3380   ED09 1A          	LD	A,(DE)
3381   ED0A BE          	CP	(HL)		;directory's extent already greater than the
3382   ED0B DA 17 ED    	JP	C,CLOSEIT6	;users extent?
3383   ED0E 77          	LD	(HL),A		;no, update directory extent.
3384   ED0F 01 03 00    	LD	BC,3		;and update the record count byte in
3385   ED12 09          	ADD	HL,BC		;directories fcb.
3386   ED13 EB          	EX	DE,HL
3387   ED14 09          	ADD	HL,BC
3388   ED15 7E          	LD	A,(HL)		;get from user.
3389   ED16 12          	LD	(DE),A		;and put in directory.
3390   ED17             CLOSEIT6:
3391   ED17 3E FF       	LD	A,0FFH		;set 'was open and is now closed' byte.
3392   ED19 32 D3 F1    	LD	(CLOSEFLG),A
3393   ED1C C3 10 EC    	JP	UPDATE1		;update the directory now.
3394   ED1F             CLOSEIT7:
3395   ED1F 21 45 E7    	LD	HL,STATUS	;set return status and then return.
3396   ED22 35          	DEC	(HL)
3397   ED23 C9          	RET	
3398   ED24             ;
3399   ED24             ;-------------------------------------------------------------
3400   ED24             ;   Routine to get the next empty space in the directory. It
3401   ED24             ; will then be cleared for use.
3402   ED24             ;
3403   ED24             GETEMPTY:
3404   ED24 CD 54 E9    	CALL	CHKWPRT		;make sure disk is not write protected.
3405   ED27 2A 43 E7    	LD	HL,(PARAMS)	;save current parameters (fcb).
3406   ED2A E5          	PUSH	HL
3407   ED2B 21 AD F1    	LD	HL,EMPTYFCB	;use special one for empty space.
3408   ED2E 22 43 E7    	LD	(PARAMS),HL
3409   ED31 0E 01       	LD	C,1		;search for first empty spot in directory.
3410   ED33 CD 18 EB    	CALL	FINDFST		;(* only check first byte *)
3411   ED36 CD F5 E9    	CALL	CKFILPOS	;none?
3412   ED39 E1          	POP	HL
3413   ED3A 22 43 E7    	LD	(PARAMS),HL	;restore original fcb address.
3414   ED3D C8          	RET	Z		;return if no more space.
3415   ED3E EB          	EX	DE,HL
TASM Z80 Assembler.               cpm22.z80                        page 63
 CP/M Ver 2.2 BDOS

3416   ED3F 21 0F 00    	LD	HL,15		;point to number of records for this file.
3417   ED42 19          	ADD	HL,DE
3418   ED43 0E 11       	LD	C,17		;and clear all of this space.
3419   ED45 AF          	XOR	A
3420   ED46             GETMT1:
3421   ED46 77          	LD	(HL),A
3422   ED47 23          	INC	HL
3423   ED48 0D          	DEC	C
3424   ED49 C2 46 ED    	JP	NZ,GETMT1
3425   ED4C 21 0D 00    	LD	HL,13		;clear the 's1' byte also.
3426   ED4F 19          	ADD	HL,DE
3427   ED50 77          	LD	(HL),A
3428   ED51 CD 8C E9    	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
3429   ED54 CD FD EB    	CALL	FCBSET		;write out this fcb entry to directory.
3430   ED57 C3 78 E9    	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
3431   ED5A             ;
3432   ED5A             ;-------------------------------------------------------------
3433   ED5A             ;   Routine to close the current extent and open the next one
3434   ED5A             ; for reading.
3435   ED5A             ;
3436   ED5A             GETNEXT:
3437   ED5A AF          	XOR	A
3438   ED5B 32 D3 F1    	LD	(CLOSEFLG),A	;clear close flag.
3439   ED5E CD A2 EC    	CALL	CLOSEIT		;close this extent.
3440   ED61 CD F5 E9    	CALL	CKFILPOS
3441   ED64 C8          	RET	Z		;not there???
3442   ED65 2A 43 E7    	LD	HL,(PARAMS)	;get extent byte.
3443   ED68 01 0C 00    	LD	BC,12
3444   ED6B 09          	ADD	HL,BC
3445   ED6C 7E          	LD	A,(HL)		;and increment it.
3446   ED6D 3C          	INC	A
3447   ED6E E6 1F       	AND	1FH		;keep within range 0-31.
3448   ED70 77          	LD	(HL),A
3449   ED71 CA 83 ED    	JP	Z,GTNEXT1	;overflow?
3450   ED74 47          	LD	B,A		;mask extent byte.
3451   ED75 3A C6 F1    	LD	A,(EXTMASK)
3452   ED78 A0          	AND	B
3453   ED79 21 D3 F1    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
3454   ED7C A6          	AND	(HL)
3455   ED7D CA 8E ED    	JP	Z,GTNEXT2	;if zero, we must read in next extent.
3456   ED80 C3 AC ED    	JP	GTNEXT3		;else, it is already in memory.
3457   ED83             GTNEXT1:
3458   ED83 01 02 00    	LD	BC,2		;Point to the 's2' byte.
3459   ED86 09          	ADD	HL,BC
3460   ED87 34          	INC	(HL)		;and bump it.
3461   ED88 7E          	LD	A,(HL)		;too many extents?
3462   ED89 E6 0F       	AND	0FH
3463   ED8B CA B6 ED    	JP	Z,GTNEXT5	;yes, set error code.
3464   ED8E             ;
3465   ED8E             ;   Get here to open the next extent.
3466   ED8E             ;
3467   ED8E             GTNEXT2:
3468   ED8E 0E 0F       	LD	C,15		;set to check first 15 bytes of fcb.
3469   ED90 CD 18 EB    	CALL	FINDFST		;find the first one.
3470   ED93 CD F5 E9    	CALL	CKFILPOS	;none available?
3471   ED96 C2 AC ED    	JP	NZ,GTNEXT3
3472   ED99 3A D4 F1    	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
3473   ED9C 3C          	INC	A		;0ffh means reading (so not possible).
3474   ED9D CA B6 ED    	JP	Z,GTNEXT5	;or an error.
TASM Z80 Assembler.               cpm22.z80                        page 64
 CP/M Ver 2.2 BDOS

3475   EDA0 CD 24 ED    	CALL	GETEMPTY	;we are writing, get an empty entry.
3476   EDA3 CD F5 E9    	CALL	CKFILPOS	;none?
3477   EDA6 CA B6 ED    	JP	Z,GTNEXT5	;error if true.
3478   EDA9 C3 AF ED    	JP	GTNEXT4		;else we are almost done.
3479   EDAC             GTNEXT3:
3480   EDAC CD 5A EC    	CALL	OPENIT1		;open this extent.
3481   EDAF             GTNEXT4:
3482   EDAF CD BB E8    	CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
3483   EDB2 AF          	XOR	A		;clear status and return.
3484   EDB3 C3 01 E7    	JP	SETSTAT
3485   EDB6             ;
3486   EDB6             ;   Error in extending the file. Too many extents were needed
3487   EDB6             ; or not enough space on the disk.
3488   EDB6             ;
3489   EDB6             GTNEXT5:
3490   EDB6 CD 05 E7    	CALL	IOERR1		;set error code, clear bit 7 of 's2'
3491   EDB9 C3 78 E9    	JP	SETS2B7		;so this is not written on a close.
3492   EDBC             ;
3493   EDBC             ;-------------------------------------------------------------
3494   EDBC             ;   Read a sequential file.
3495   EDBC             ;
3496   EDBC             RDSEQ:
3497   EDBC 3E 01       	LD	A,1		;set sequential access mode.
3498   EDBE 32 D6 F1    	LD	(MODE),A
3499   EDC1             RDSEQ1:
3500   EDC1 3E FF       	LD	A,0FFH		;don't allow reading unwritten space.
3501   EDC3 32 D4 F1    	LD	(RDWRTFLG),A
3502   EDC6 CD BB E8    	CALL	STRDATA		;put rec# and ext# into fcb.
3503   EDC9 3A E4 F1    	LD	A,(SAVNREC)	;get next record to read.
3504   EDCC 21 E2 F1    	LD	HL,SAVNXT	;get number of records in extent.
3505   EDCF BE          	CP	(HL)		;within this extent?
3506   EDD0 DA E6 ED    	JP	C,RDSEQ2
3507   EDD3 FE 80       	CP	128		;no. Is this extent fully used?
3508   EDD5 C2 FB ED    	JP	NZ,RDSEQ3	;no. End-of-file.
3509   EDD8 CD 5A ED    	CALL	GETNEXT		;yes, open the next one.
3510   EDDB AF          	XOR	A		;reset next record to read.
3511   EDDC 32 E4 F1    	LD	(SAVNREC),A
3512   EDDF 3A 45 E7    	LD	A,(STATUS)	;check on open, successful?
3513   EDE2 B7          	OR	A
3514   EDE3 C2 FB ED    	JP	NZ,RDSEQ3	;no, error.
3515   EDE6             RDSEQ2:
3516   EDE6 CD 77 E8    	CALL	COMBLK		;ok. compute block number to read.
3517   EDE9 CD 84 E8    	CALL	CHKBLK		;check it. Within bounds?
3518   EDEC CA FB ED    	JP	Z,RDSEQ3	;no, error.
3519   EDEF CD 8A E8    	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
3520   EDF2 CD D1 E7    	CALL	TRKSEC1		;set the track and sector for this block #.
3521   EDF5 CD B2 E7    	CALL	DOREAD		;and read it.
3522   EDF8 C3 D2 E8    	JP	SETNREC		;and set the next record to be accessed.
3523   EDFB             ;
3524   EDFB             ;   Read error occured. Set status and return.
3525   EDFB             ;
3526   EDFB             RDSEQ3:
3527   EDFB C3 05 E7    	JP	IOERR1
3528   EDFE             ;
3529   EDFE             ;-------------------------------------------------------------
3530   EDFE             ;   Write the next sequential record.
3531   EDFE             ;
3532   EDFE             WTSEQ:
3533   EDFE 3E 01       	LD	A,1		;set sequential access mode.
TASM Z80 Assembler.               cpm22.z80                        page 65
 CP/M Ver 2.2 BDOS

3534   EE00 32 D6 F1    	LD	(MODE),A
3535   EE03             WTSEQ1:
3536   EE03 3E 00       	LD	A,0		;allow an addition empty extent to be opened.
3537   EE05 32 D4 F1    	LD	(RDWRTFLG),A
3538   EE08 CD 54 E9    	CALL	CHKWPRT		;check write protect status.
3539   EE0B 2A 43 E7    	LD	HL,(PARAMS)
3540   EE0E CD 47 E9    	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
3541   EE11 CD BB E8    	CALL	STRDATA		;put updated data into fcb.
3542   EE14 3A E4 F1    	LD	A,(SAVNREC)	;get record number to write.
3543   EE17 FE 80       	CP	128		;within range?
3544   EE19 D2 05 E7    	JP	NC,IOERR1	;no, error(?).
3545   EE1C CD 77 E8    	CALL	COMBLK		;compute block number.
3546   EE1F CD 84 E8    	CALL	CHKBLK		;check number.
3547   EE22 0E 00       	LD	C,0		;is there one to write to?
3548   EE24 C2 6E EE    	JP	NZ,WTSEQ6	;yes, go do it.
3549   EE27 CD 3E E8    	CALL	GETBLOCK	;get next block number within fcb to use.
3550   EE2A 32 D8 F1    	LD	(RELBLOCK),A	;and save.
3551   EE2D 01 00 00    	LD	BC,0		;start looking for space from the start
3552   EE30 B7          	OR	A		;if none allocated as yet.
3553   EE31 CA 3B EE    	JP	Z,WTSEQ2
3554   EE34 4F          	LD	C,A		;extract previous block number from fcb
3555   EE35 0B          	DEC	BC		;so we can be closest to it.
3556   EE36 CD 5E E8    	CALL	EXTBLK
3557   EE39 44          	LD	B,H
3558   EE3A 4D          	LD	C,L
3559   EE3B             WTSEQ2:
3560   EE3B CD BE EB    	CALL	FNDSPACE	;find the next empty block nearest number (BC).
3561   EE3E 7D          	LD	A,L		;check for a zero number.
3562   EE3F B4          	OR	H
3563   EE40 C2 48 EE    	JP	NZ,WTSEQ3
3564   EE43 3E 02       	LD	A,2		;no more space?
3565   EE45 C3 01 E7    	JP	SETSTAT
3566   EE48             WTSEQ3:
3567   EE48 22 E6 F1    	LD	(BLKNMBR),HL	;save block number to access.
3568   EE4B EB          	EX	DE,HL		;put block number into (DE).
3569   EE4C 2A 43 E7    	LD	HL,(PARAMS)	;now we must update the fcb for this
3570   EE4F 01 10 00    	LD	BC,16		;newly allocated block.
3571   EE52 09          	ADD	HL,BC
3572   EE53 3A DE F1    	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
3573   EE56 B7          	OR	A
3574   EE57 3A D8 F1    	LD	A,(RELBLOCK)	;(* update this entry *)
3575   EE5A CA 64 EE    	JP	Z,WTSEQ4	;zero means 16 bit ones.
3576   EE5D CD 64 E9    	CALL	ADDA2HL		;(HL)=(HL)+(A)
3577   EE60 73          	LD	(HL),E		;store new block number.
3578   EE61 C3 6C EE    	JP	WTSEQ5
3579   EE64             WTSEQ4:
3580   EE64 4F          	LD	C,A		;compute spot in this 16 bit table.
3581   EE65 06 00       	LD	B,0
3582   EE67 09          	ADD	HL,BC
3583   EE68 09          	ADD	HL,BC
3584   EE69 73          	LD	(HL),E		;stuff block number (DE) there.
3585   EE6A 23          	INC	HL
3586   EE6B 72          	LD	(HL),D
3587   EE6C             WTSEQ5:
3588   EE6C 0E 02       	LD	C,2		;set (C) to indicate writing to un-used disk space.
3589   EE6E             WTSEQ6:
3590   EE6E 3A 45 E7    	LD	A,(STATUS)	;are we ok so far?
3591   EE71 B7          	OR	A
3592   EE72 C0          	RET	NZ
TASM Z80 Assembler.               cpm22.z80                        page 66
 CP/M Ver 2.2 BDOS

3593   EE73 C5          	PUSH	BC		;yes, save write flag for bios (register C).
3594   EE74 CD 8A E8    	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
3595   EE77 3A D6 F1    	LD	A,(MODE)	;get access mode flag (1=sequential,
3596   EE7A 3D          	DEC	A		;0=random, 2=special?).
3597   EE7B 3D          	DEC	A
3598   EE7C C2 BB EE    	JP	NZ,WTSEQ9
3599   EE7F             ;
3600   EE7F             ;   Special random i/o from function #40. Maybe for M/PM, but the
3601   EE7F             ; current block, if it has not been written to, will be zeroed
3602   EE7F             ; out and then written (reason?).
3603   EE7F             ;
3604   EE7F C1          	POP	BC
3605   EE80 C5          	PUSH	BC
3606   EE81 79          	LD	A,C		;get write status flag (2=writing unused space).
3607   EE82 3D          	DEC	A
3608   EE83 3D          	DEC	A
3609   EE84 C2 BB EE    	JP	NZ,WTSEQ9
3610   EE87 E5          	PUSH	HL
3611   EE88 2A BA F1    	LD	HL,(DIRBUF)	;zero out the directory buffer.
3612   EE8B 57          	LD	D,A		;note that (A) is zero here.
3613   EE8C             WTSEQ7:
3614   EE8C 77          	LD	(HL),A
3615   EE8D 23          	INC	HL
3616   EE8E 14          	INC	D		;do 128 bytes.
3617   EE8F F2 8C EE    	JP	P,WTSEQ7
3618   EE92 CD E0 E9    	CALL	DIRDMA		;tell the bios the dma address for directory access.
3619   EE95 2A E8 F1    	LD	HL,(LOGSECT)	;get sector that starts current block.
3620   EE98 0E 02       	LD	C,2		;set 'writing to unused space' flag.
3621   EE9A             WTSEQ8:
3622   EE9A 22 E6 F1    	LD	(BLKNMBR),HL	;save sector to write.
3623   EE9D C5          	PUSH	BC
3624   EE9E CD D1 E7    	CALL	TRKSEC1		;determine its track and sector numbers.
3625   EEA1 C1          	POP	BC
3626   EEA2 CD B8 E7    	CALL	DOWRITE		;now write out 128 bytes of zeros.
3627   EEA5 2A E6 F1    	LD	HL,(BLKNMBR)	;get sector number.
3628   EEA8 0E 00       	LD	C,0		;set normal write flag.
3629   EEAA 3A C5 F1    	LD	A,(BLKMASK)	;determine if we have written the entire
3630   EEAD 47          	LD	B,A		;physical block.
3631   EEAE A5          	AND	L
3632   EEAF B8          	CP	B
3633   EEB0 23          	INC	HL		;prepare for the next one.
3634   EEB1 C2 9A EE    	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
3635   EEB4 E1          	POP	HL		;reset next sector number.
3636   EEB5 22 E6 F1    	LD	(BLKNMBR),HL
3637   EEB8 CD DA E9    	CALL	DEFDMA		;and reset dma address.
3638   EEBB             ;
3639   EEBB             ;   Normal disk write. Set the desired track and sector then
3640   EEBB             ; do the actual write.
3641   EEBB             ;
3642   EEBB             WTSEQ9:
3643   EEBB CD D1 E7    	CALL	TRKSEC1		;determine track and sector for this write.
3644   EEBE C1          	POP	BC		;get write status flag.
3645   EEBF C5          	PUSH	BC
3646   EEC0 CD B8 E7    	CALL	DOWRITE		;and write this out.
3647   EEC3 C1          	POP	BC
3648   EEC4 3A E4 F1    	LD	A,(SAVNREC)	;get number of records in file.
3649   EEC7 21 E2 F1    	LD	HL,SAVNXT	;get last record written.
3650   EECA BE          	CP	(HL)
3651   EECB DA D2 EE    	JP	C,WTSEQ10
TASM Z80 Assembler.               cpm22.z80                        page 67
 CP/M Ver 2.2 BDOS

3652   EECE 77          	LD	(HL),A		;we have to update record count.
3653   EECF 34          	INC	(HL)
3654   EED0 0E 02       	LD	C,2
3655   EED2             ;
3656   EED2             ;*   This area has been patched to correct disk update problem
3657   EED2             ;* when using blocking and de-blocking in the BIOS.
3658   EED2             ;
3659   EED2             WTSEQ10:
3660   EED2 00          	NOP			;was 'dcr c'
3661   EED3 00          	NOP			;was 'dcr c'
3662   EED4 21 00 00    	LD	HL,0		;was 'jnz wtseq99'
3663   EED7             ;
3664   EED7             ; *   End of patch.
3665   EED7             ;
3666   EED7 F5          	PUSH	AF
3667   EED8 CD 69 E9    	CALL	GETS2		;set 'extent written to' flag.
3668   EEDB E6 7F       	AND	7FH		;(* clear bit 7 *)
3669   EEDD 77          	LD	(HL),A
3670   EEDE F1          	POP	AF		;get record count for this extent.
3671   EEDF             WTSEQ99:
3672   EEDF FE 7F       	CP	127		;is it full?
3673   EEE1 C2 00 EF    	JP	NZ,WTSEQ12
3674   EEE4 3A D6 F1    	LD	A,(MODE)	;yes, are we in sequential mode?
3675   EEE7 FE 01       	CP	1
3676   EEE9 C2 00 EF    	JP	NZ,WTSEQ12
3677   EEEC CD D2 E8    	CALL	SETNREC		;yes, set next record number.
3678   EEEF CD 5A ED    	CALL	GETNEXT		;and get next empty space in directory.
3679   EEF2 21 45 E7    	LD	HL,STATUS	;ok?
3680   EEF5 7E          	LD	A,(HL)
3681   EEF6 B7          	OR	A
3682   EEF7 C2 FE EE    	JP	NZ,WTSEQ11
3683   EEFA 3D          	DEC	A		;yes, set record count to -1.
3684   EEFB 32 E4 F1    	LD	(SAVNREC),A
3685   EEFE             WTSEQ11:
3686   EEFE 36 00       	LD	(HL),0		;clear status.
3687   EF00             WTSEQ12:
3688   EF00 C3 D2 E8    	JP	SETNREC		;set next record to access.
3689   EF03             ;
3690   EF03             ;-------------------------------------------------------------
3691   EF03             ;   For random i/o, set the fcb for the desired record number
3692   EF03             ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3693   EF03             ; used as follows:
3694   EF03             ;
3695   EF03             ;       fcb+35            fcb+34            fcb+33
3696   EF03             ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3697   EF03             ;  |7             0 | 7             0 | 7             0|
3698   EF03             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3699   EF03             ;  |    overflow   | | extra |  extent   |   record #  |
3700   EF03             ;  | ______________| |_extent|__number___|_____________|
3701   EF03             ;                     also 's2'
3702   EF03             ;
3703   EF03             ;   On entry, register (C) contains 0ffh if this is a read
3704   EF03             ; and thus we can not access unwritten disk space. Otherwise,
3705   EF03             ; another extent will be opened (for writing) if required.
3706   EF03             ;
3707   EF03             POSITION:
3708   EF03 AF          	XOR	A		;set random i/o flag.
3709   EF04 32 D6 F1    	LD	(MODE),A
3710   EF07             ;
TASM Z80 Assembler.               cpm22.z80                        page 68
 CP/M Ver 2.2 BDOS

3711   EF07             ;   Special entry (function #40). M/PM ?
3712   EF07             ;
3713   EF07             POSITN1:
3714   EF07 C5          	PUSH	BC		;save read/write flag.
3715   EF08 2A 43 E7    	LD	HL,(PARAMS)	;get address of fcb.
3716   EF0B EB          	EX	DE,HL
3717   EF0C 21 21 00    	LD	HL,33		;now get byte 'r0'.
3718   EF0F 19          	ADD	HL,DE
3719   EF10 7E          	LD	A,(HL)
3720   EF11 E6 7F       	AND	7FH		;keep bits 0-6 for the record number to access.
3721   EF13 F5          	PUSH	AF
3722   EF14 7E          	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3723   EF15 17          	RLA	
3724   EF16 23          	INC	HL
3725   EF17 7E          	LD	A,(HL)
3726   EF18 17          	RLA	
3727   EF19 E6 1F       	AND	1FH		;and save this in bits 0-4 of (C).
3728   EF1B 4F          	LD	C,A		;this is the extent byte.
3729   EF1C 7E          	LD	A,(HL)		;now get the extra extent byte.
3730   EF1D 1F          	RRA	
3731   EF1E 1F          	RRA	
3732   EF1F 1F          	RRA	
3733   EF20 1F          	RRA	
3734   EF21 E6 0F       	AND	0FH
3735   EF23 47          	LD	B,A		;and save it in (B).
3736   EF24 F1          	POP	AF		;get record number back to (A).
3737   EF25 23          	INC	HL		;check overflow byte 'r2'.
3738   EF26 6E          	LD	L,(HL)
3739   EF27 2C          	INC	L
3740   EF28 2D          	DEC	L
3741   EF29 2E 06       	LD	L,6		;prepare for error.
3742   EF2B C2 8B EF    	JP	NZ,POSITN5	;out of disk space error.
3743   EF2E 21 20 00    	LD	HL,32		;store record number into fcb.
3744   EF31 19          	ADD	HL,DE
3745   EF32 77          	LD	(HL),A
3746   EF33 21 0C 00    	LD	HL,12		;and now check the extent byte.
3747   EF36 19          	ADD	HL,DE
3748   EF37 79          	LD	A,C
3749   EF38 96          	SUB	(HL)		;same extent as before?
3750   EF39 C2 47 EF    	JP	NZ,POSITN2
3751   EF3C 21 0E 00    	LD	HL,14		;yes, check extra extent byte 's2' also.
3752   EF3F 19          	ADD	HL,DE
3753   EF40 78          	LD	A,B
3754   EF41 96          	SUB	(HL)
3755   EF42 E6 7F       	AND	7FH
3756   EF44 CA 7F EF    	JP	Z,POSITN3	;same, we are almost done then.
3757   EF47             ;
3758   EF47             ;  Get here when another extent is required.
3759   EF47             ;
3760   EF47             POSITN2:
3761   EF47 C5          	PUSH	BC
3762   EF48 D5          	PUSH	DE
3763   EF49 CD A2 EC    	CALL	CLOSEIT		;close current extent.
3764   EF4C D1          	POP	DE
3765   EF4D C1          	POP	BC
3766   EF4E 2E 03       	LD	L,3		;prepare for error.
3767   EF50 3A 45 E7    	LD	A,(STATUS)
3768   EF53 3C          	INC	A
3769   EF54 CA 84 EF    	JP	Z,POSITN4	;close error.
TASM Z80 Assembler.               cpm22.z80                        page 69
 CP/M Ver 2.2 BDOS

3770   EF57 21 0C 00    	LD	HL,12		;put desired extent into fcb now.
3771   EF5A 19          	ADD	HL,DE
3772   EF5B 71          	LD	(HL),C
3773   EF5C 21 0E 00    	LD	HL,14		;and store extra extent byte 's2'.
3774   EF5F 19          	ADD	HL,DE
3775   EF60 70          	LD	(HL),B
3776   EF61 CD 51 EC    	CALL	OPENIT		;try and get this extent.
3777   EF64 3A 45 E7    	LD	A,(STATUS)	;was it there?
3778   EF67 3C          	INC	A
3779   EF68 C2 7F EF    	JP	NZ,POSITN3
3780   EF6B C1          	POP	BC		;no. can we create a new one (writing?).
3781   EF6C C5          	PUSH	BC
3782   EF6D 2E 04       	LD	L,4		;prepare for error.
3783   EF6F 0C          	INC	C
3784   EF70 CA 84 EF    	JP	Z,POSITN4	;nope, reading unwritten space error.
3785   EF73 CD 24 ED    	CALL	GETEMPTY	;yes we can, try to find space.
3786   EF76 2E 05       	LD	L,5		;prepare for error.
3787   EF78 3A 45 E7    	LD	A,(STATUS)
3788   EF7B 3C          	INC	A
3789   EF7C CA 84 EF    	JP	Z,POSITN4	;out of space?
3790   EF7F             ;
3791   EF7F             ;   Normal return location. Clear error code and return.
3792   EF7F             ;
3793   EF7F             POSITN3:
3794   EF7F C1          	POP	BC		;restore stack.
3795   EF80 AF          	XOR	A		;and clear error code byte.
3796   EF81 C3 01 E7    	JP	SETSTAT
3797   EF84             ;
3798   EF84             ;   Error. Set the 's2' byte to indicate this (why?).
3799   EF84             ;
3800   EF84             POSITN4:
3801   EF84 E5          	PUSH	HL
3802   EF85 CD 69 E9    	CALL	GETS2
3803   EF88 36 C0       	LD	(HL),0C0H
3804   EF8A E1          	POP	HL
3805   EF8B             ;
3806   EF8B             ;   Return with error code (presently in L).
3807   EF8B             ;
3808   EF8B             POSITN5:
3809   EF8B C1          	POP	BC
3810   EF8C 7D          	LD	A,L		;get error code.
3811   EF8D 32 45 E7    	LD	(STATUS),A
3812   EF90 C3 78 E9    	JP	SETS2B7
3813   EF93             ;
3814   EF93             ;-------------------------------------------------------------
3815   EF93             ;   Read a random record.
3816   EF93             ;
3817   EF93             READRAN:
3818   EF93 0E FF       	LD	C,0FFH		;set 'read' status.
3819   EF95 CD 03 EF    	CALL	POSITION	;position the file to proper record.
3820   EF98 CC C1 ED    	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
3821   EF9B C9          	RET	
3822   EF9C             ;
3823   EF9C             ;-------------------------------------------------------------
3824   EF9C             ;   Write to a random record.
3825   EF9C             ;
3826   EF9C             WRITERAN:
3827   EF9C 0E 00       	LD	C,0		;set 'writing' flag.
3828   EF9E CD 03 EF    	CALL	POSITION	;position the file to proper record.
TASM Z80 Assembler.               cpm22.z80                        page 70
 CP/M Ver 2.2 BDOS

3829   EFA1 CC 03 EE    	CALL	Z,WTSEQ1	;and write as usual (if no errors).
3830   EFA4 C9          	RET	
3831   EFA5             ;
3832   EFA5             ;-------------------------------------------------------------
3833   EFA5             ;   Compute the random record number. Enter with (HL) pointing
3834   EFA5             ; to a fcb an (DE) contains a relative location of a record
3835   EFA5             ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3836   EFA5             ; byte, and (A) the 'r2' byte.
3837   EFA5             ;
3838   EFA5             ;   On return, the zero flag is set if the record is within
3839   EFA5             ; bounds. Otherwise, an overflow occured.
3840   EFA5             ;
3841   EFA5             COMPRAND:
3842   EFA5 EB          	EX	DE,HL		;save fcb pointer in (DE).
3843   EFA6 19          	ADD	HL,DE		;compute relative position of record #.
3844   EFA7 4E          	LD	C,(HL)		;get record number into (BC).
3845   EFA8 06 00       	LD	B,0
3846   EFAA 21 0C 00    	LD	HL,12		;now get extent.
3847   EFAD 19          	ADD	HL,DE
3848   EFAE 7E          	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
3849   EFAF 0F          	RRCA			;move lower bit into bit 7.
3850   EFB0 E6 80       	AND	80H		;and ignore all other bits.
3851   EFB2 81          	ADD	A,C		;add to our record number.
3852   EFB3 4F          	LD	C,A
3853   EFB4 3E 00       	LD	A,0		;take care of any carry.
3854   EFB6 88          	ADC	A,B
3855   EFB7 47          	LD	B,A
3856   EFB8 7E          	LD	A,(HL)		;now get the upper bits of extent into
3857   EFB9 0F          	RRCA			;bit positions 0-3.
3858   EFBA E6 0F       	AND	0FH		;and ignore all others.
3859   EFBC 80          	ADD	A,B		;add this in to 'r1' byte.
3860   EFBD 47          	LD	B,A
3861   EFBE 21 0E 00    	LD	HL,14		;get the 's2' byte (extra extent).
3862   EFC1 19          	ADD	HL,DE
3863   EFC2 7E          	LD	A,(HL)
3864   EFC3 87          	ADD	A,A		;and shift it left 4 bits (bits 4-7).
3865   EFC4 87          	ADD	A,A
3866   EFC5 87          	ADD	A,A
3867   EFC6 87          	ADD	A,A
3868   EFC7 F5          	PUSH	AF		;save carry flag (bit 0 of flag byte).
3869   EFC8 80          	ADD	A,B		;now add extra extent into 'r1'.
3870   EFC9 47          	LD	B,A
3871   EFCA F5          	PUSH	AF		;and save carry (overflow byte 'r2').
3872   EFCB E1          	POP	HL		;bit 0 of (L) is the overflow indicator.
3873   EFCC 7D          	LD	A,L
3874   EFCD E1          	POP	HL		;and same for first carry flag.
3875   EFCE B5          	OR	L		;either one of these set?
3876   EFCF E6 01       	AND	01H		;only check the carry flags.
3877   EFD1 C9          	RET	
3878   EFD2             ;
3879   EFD2             ;-------------------------------------------------------------
3880   EFD2             ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3881   EFD2             ; reflect the last record used for a random (or other) file.
3882   EFD2             ; This reads the directory and looks at all extents computing
3883   EFD2             ; the largerst record number for each and keeping the maximum
3884   EFD2             ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3885   EFD2             ; maximum record number. This is used to compute the space used
3886   EFD2             ; by a random file.
3887   EFD2             ;
TASM Z80 Assembler.               cpm22.z80                        page 71
 CP/M Ver 2.2 BDOS

3888   EFD2             RANSIZE:
3889   EFD2 0E 0C       	LD	C,12		;look thru directory for first entry with
3890   EFD4 CD 18 EB    	CALL	FINDFST		;this name.
3891   EFD7 2A 43 E7    	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
3892   EFDA 11 21 00    	LD	DE,33
3893   EFDD 19          	ADD	HL,DE
3894   EFDE E5          	PUSH	HL
3895   EFDF 72          	LD	(HL),D		;note that (D)=0.
3896   EFE0 23          	INC	HL
3897   EFE1 72          	LD	(HL),D
3898   EFE2 23          	INC	HL
3899   EFE3 72          	LD	(HL),D
3900   EFE4             RANSIZ1:
3901   EFE4 CD F5 E9    	CALL	CKFILPOS	;is there an extent to process?
3902   EFE7 CA 0C F0    	JP	Z,RANSIZ3	;no, we are done.
3903   EFEA CD 5E E9    	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
3904   EFED 11 0F 00    	LD	DE,15		;point to last record in extent.
3905   EFF0 CD A5 EF    	CALL	COMPRAND	;and compute random parameters.
3906   EFF3 E1          	POP	HL
3907   EFF4 E5          	PUSH	HL		;now check these values against those
3908   EFF5 5F          	LD	E,A		;already in fcb.
3909   EFF6 79          	LD	A,C		;the carry flag will be set if those
3910   EFF7 96          	SUB	(HL)		;in the fcb represent a larger size than
3911   EFF8 23          	INC	HL		;this extent does.
3912   EFF9 78          	LD	A,B
3913   EFFA 9E          	SBC	A,(HL)
3914   EFFB 23          	INC	HL
3915   EFFC 7B          	LD	A,E
3916   EFFD 9E          	SBC	A,(HL)
3917   EFFE DA 06 F0    	JP	C,RANSIZ2
3918   F001 73          	LD	(HL),E		;we found a larger (in size) extent.
3919   F002 2B          	DEC	HL		;stuff these values into fcb.
3920   F003 70          	LD	(HL),B
3921   F004 2B          	DEC	HL
3922   F005 71          	LD	(HL),C
3923   F006             RANSIZ2:
3924   F006 CD 2D EB    	CALL	FINDNXT		;now get the next extent.
3925   F009 C3 E4 EF    	JP	RANSIZ1		;continue til all done.
3926   F00C             RANSIZ3:
3927   F00C E1          	POP	HL		;we are done, restore the stack and
3928   F00D C9          	RET			;return.
3929   F00E             ;
3930   F00E             ;-------------------------------------------------------------
3931   F00E             ;   Function to return the random record position of a given
3932   F00E             ; file which has been read in sequential mode up to now.
3933   F00E             ;
3934   F00E             SETRAN:
3935   F00E 2A 43 E7    	LD	HL,(PARAMS)	;point to fcb.
3936   F011 11 20 00    	LD	DE,32		;and to last used record.
3937   F014 CD A5 EF    	CALL	COMPRAND	;compute random position.
3938   F017 21 21 00    	LD	HL,33		;now stuff these values into fcb.
3939   F01A 19          	ADD	HL,DE
3940   F01B 71          	LD	(HL),C		;move 'r0'.
3941   F01C 23          	INC	HL
3942   F01D 70          	LD	(HL),B		;and 'r1'.
3943   F01E 23          	INC	HL
3944   F01F 77          	LD	(HL),A		;and lastly 'r2'.
3945   F020 C9          	RET	
3946   F021             ;
TASM Z80 Assembler.               cpm22.z80                        page 72
 CP/M Ver 2.2 BDOS

3947   F021             ;-------------------------------------------------------------
3948   F021             ;   This routine select the drive specified in (ACTIVE) and
3949   F021             ; update the login vector and bitmap table if this drive was
3950   F021             ; not already active.
3951   F021             ;
3952   F021             LOGINDRV:
3953   F021 2A B0 F1    	LD	HL,(LOGIN)	;get the login vector.
3954   F024 3A 42 E7    	LD	A,(ACTIVE)	;get the default drive.
3955   F027 4F          	LD	C,A
3956   F028 CD EA E8    	CALL	SHIFTR		;position active bit for this drive
3957   F02B E5          	PUSH	HL		;into bit 0.
3958   F02C EB          	EX	DE,HL
3959   F02D CD 59 E7    	CALL	SELECT		;select this drive.
3960   F030 E1          	POP	HL
3961   F031 CC 47 E7    	CALL	Z,SLCTERR	;valid drive?
3962   F034 7D          	LD	A,L		;is this a newly activated drive?
3963   F035 1F          	RRA	
3964   F036 D8          	RET	C
3965   F037 2A B0 F1    	LD	HL,(LOGIN)	;yes, update the login vector.
3966   F03A 4D          	LD	C,L
3967   F03B 44          	LD	B,H
3968   F03C CD 0B E9    	CALL	SETBIT
3969   F03F 22 B0 F1    	LD	(LOGIN),HL	;and save.
3970   F042 C3 A3 EA    	JP	BITMAP		;now update the bitmap.
3971   F045             ;
3972   F045             ;-------------------------------------------------------------
3973   F045             ;   Function to set the active disk number.
3974   F045             ;
3975   F045             SETDSK:
3976   F045 3A D7 F1    	LD	A,(EPARAM)	;get parameter passed and see if this
3977   F048 21 42 E7    	LD	HL,ACTIVE	;represents a change in drives.
3978   F04B BE          	CP	(HL)
3979   F04C C8          	RET	Z
3980   F04D 77          	LD	(HL),A		;yes it does, log it in.
3981   F04E C3 21 F0    	JP	LOGINDRV
3982   F051             ;
3983   F051             ;-------------------------------------------------------------
3984   F051             ;   This is the 'auto disk select' routine. The firsst byte
3985   F051             ; of the fcb is examined for a drive specification. If non
3986   F051             ; zero then the drive will be selected and loged in.
3987   F051             ;
3988   F051             AUTOSEL:
3989   F051 3E FF       	LD	A,0FFH		;say 'auto-select activated'.
3990   F053 32 DF F1    	LD	(AUTO),A
3991   F056 2A 43 E7    	LD	HL,(PARAMS)	;get drive specified.
3992   F059 7E          	LD	A,(HL)
3993   F05A E6 1F       	AND	1FH		;look at lower 5 bits.
3994   F05C 3D          	DEC	A		;adjust for (1=A, 2=B) etc.
3995   F05D 32 D7 F1    	LD	(EPARAM),A	;and save for the select routine.
3996   F060 FE 1E       	CP	1EH		;check for 'no change' condition.
3997   F062 D2 75 F0    	JP	NC,AUTOSL1	;yes, don't change.
3998   F065 3A 42 E7    	LD	A,(ACTIVE)	;we must change, save currently active
3999   F068 32 E0 F1    	LD	(OLDDRV),A	;drive.
4000   F06B 7E          	LD	A,(HL)		;and save first byte of fcb also.
4001   F06C 32 E1 F1    	LD	(AUTOFLAG),A	;this must be non-zero.
4002   F06F E6 E0       	AND	0E0H		;whats this for (bits 6,7 are used for
4003   F071 77          	LD	(HL),A		;something)?
4004   F072 CD 45 F0    	CALL	SETDSK		;select and log in this drive.
4005   F075             AUTOSL1:
TASM Z80 Assembler.               cpm22.z80                        page 73
 CP/M Ver 2.2 BDOS

4006   F075 3A 41 E7    	LD	A,(USERNO)	;move user number into fcb.
4007   F078 2A 43 E7    	LD	HL,(PARAMS)	;(* upper half of first byte *)
4008   F07B B6          	OR	(HL)
4009   F07C 77          	LD	(HL),A
4010   F07D C9          	RET			;and return (all done).
4011   F07E             ;
4012   F07E             ;-------------------------------------------------------------
4013   F07E             ;   Function to return the current cp/m version number.
4014   F07E             ;
4015   F07E             GETVER:
4016   F07E 3E 22       	LD	A,022H		;version 2.2
4017   F080 C3 01 E7    	JP	SETSTAT
4018   F083             ;
4019   F083             ;-------------------------------------------------------------
4020   F083             ;   Function to reset the disk system.
4021   F083             ;
4022   F083             RSTDSK:
4023   F083 21 00 00    	LD	HL,0		;clear write protect status and log
4024   F086 22 AE F1    	LD	(WRTPRT),HL	;in vector.
4025   F089 22 B0 F1    	LD	(LOGIN),HL
4026   F08C             ;	XOR	A		;select drive 'A'.
4027   F08C 3E 02       	LD	A,SYSDSK	;select system drive
4028   F08E 32 42 E7    	LD	(ACTIVE),A
4029   F091 21 80 00    	LD	HL,TBUFF	;setup default dma address.
4030   F094 22 B2 F1    	LD	(USERDMA),HL
4031   F097 CD DA E9    	CALL	DEFDMA
4032   F09A C3 21 F0    	JP	LOGINDRV	;now log in drive 'A'.
4033   F09D             ;
4034   F09D             ;-------------------------------------------------------------
4035   F09D             ;   Function to open a specified file.
4036   F09D             ;
4037   F09D             OPENFIL:
4038   F09D CD 72 E9    	CALL	CLEARS2		;clear 's2' byte.
4039   F0A0 CD 51 F0    	CALL	AUTOSEL		;select proper disk.
4040   F0A3 C3 51 EC    	JP	OPENIT		;and open the file.
4041   F0A6             ;
4042   F0A6             ;-------------------------------------------------------------
4043   F0A6             ;   Function to close a specified file.
4044   F0A6             ;
4045   F0A6             CLOSEFIL:
4046   F0A6 CD 51 F0    	CALL	AUTOSEL		;select proper disk.
4047   F0A9 C3 A2 EC    	JP	CLOSEIT		;and close the file.
4048   F0AC             ;
4049   F0AC             ;-------------------------------------------------------------
4050   F0AC             ;   Function to return the first occurence of a specified file
4051   F0AC             ; name. If the first byte of the fcb is '?' then the name will
4052   F0AC             ; not be checked (get the first entry no matter what).
4053   F0AC             ;
4054   F0AC             GETFST:
4055   F0AC 0E 00       	LD	C,0		;prepare for special search.
4056   F0AE EB          	EX	DE,HL
4057   F0AF 7E          	LD	A,(HL)		;is first byte a '?'?
4058   F0B0 FE 3F       	CP	'?'
4059   F0B2 CA C3 F0    	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
4060   F0B5 CD A6 E8    	CALL	SETEXT		;get the extension byte from fcb.
4061   F0B8 7E          	LD	A,(HL)		;is it '?'? if yes, then we want
4062   F0B9 FE 3F       	CP	'?'		;an entry with a specific 's2' byte.
4063   F0BB C4 72 E9    	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
4064   F0BE CD 51 F0    	CALL	AUTOSEL		;select proper drive.
TASM Z80 Assembler.               cpm22.z80                        page 74
 CP/M Ver 2.2 BDOS

4065   F0C1 0E 0F       	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
4066   F0C3             GETFST1:
4067   F0C3 CD 18 EB    	CALL	FINDFST		;find an entry and then move it into
4068   F0C6 C3 E9 E9    	JP	MOVEDIR		;the users dma space.
4069   F0C9             ;
4070   F0C9             ;-------------------------------------------------------------
4071   F0C9             ;   Function to return the next occurence of a file name.
4072   F0C9             ;
4073   F0C9             GETNXT:
4074   F0C9 2A DA F1    	LD	HL,(SAVEFCB)	;restore pointers. note that no
4075   F0CC 22 43 E7    	LD	(PARAMS),HL	;other dbos calls are allowed.
4076   F0CF CD 51 F0    	CALL	AUTOSEL		;no error will be returned, but the
4077   F0D2 CD 2D EB    	CALL	FINDNXT		;results will be wrong.
4078   F0D5 C3 E9 E9    	JP	MOVEDIR
4079   F0D8             ;
4080   F0D8             ;-------------------------------------------------------------
4081   F0D8             ;   Function to delete a file by name.
4082   F0D8             ;
4083   F0D8             DELFILE:
4084   F0D8 CD 51 F0    	CALL	AUTOSEL		;select proper drive.
4085   F0DB CD 9C EB    	CALL	ERAFILE		;erase the file.
4086   F0DE C3 01 EB    	JP	STSTATUS	;set status and return.
4087   F0E1             ;
4088   F0E1             ;-------------------------------------------------------------
4089   F0E1             ;   Function to execute a sequential read of the specified
4090   F0E1             ; record number.
4091   F0E1             ;
4092   F0E1             READSEQ:
4093   F0E1 CD 51 F0    	CALL	AUTOSEL		;select proper drive then read.
4094   F0E4 C3 BC ED    	JP	RDSEQ
4095   F0E7             ;
4096   F0E7             ;-------------------------------------------------------------
4097   F0E7             ;   Function to write the next sequential record.
4098   F0E7             ;
4099   F0E7             WRTSEQ:
4100   F0E7 CD 51 F0    	CALL	AUTOSEL		;select proper drive then write.
4101   F0EA C3 FE ED    	JP	WTSEQ
4102   F0ED             ;
4103   F0ED             ;-------------------------------------------------------------
4104   F0ED             ;   Create a file function.
4105   F0ED             ;
4106   F0ED             FCREATE:
4107   F0ED CD 72 E9    	CALL	CLEARS2		;clear the 's2' byte on all creates.
4108   F0F0 CD 51 F0    	CALL	AUTOSEL		;select proper drive and get the next
4109   F0F3 C3 24 ED    	JP	GETEMPTY	;empty directory space.
4110   F0F6             ;
4111   F0F6             ;-------------------------------------------------------------
4112   F0F6             ;   Function to rename a file.
4113   F0F6             ;
4114   F0F6             RENFILE:
4115   F0F6 CD 51 F0    	CALL	AUTOSEL		;select proper drive and then switch
4116   F0F9 CD 16 EC    	CALL	CHGNAMES	;file names.
4117   F0FC C3 01 EB    	JP	STSTATUS
4118   F0FF             ;
4119   F0FF             ;-------------------------------------------------------------
4120   F0FF             ;   Function to return the login vector.
4121   F0FF             ;
4122   F0FF             GETLOG:
4123   F0FF 2A B0 F1    	LD	HL,(LOGIN)
TASM Z80 Assembler.               cpm22.z80                        page 75
 CP/M Ver 2.2 BDOS

4124   F102 C3 2A F1    	JP	GETPRM1
4125   F105             ;
4126   F105             ;-------------------------------------------------------------
4127   F105             ;   Function to return the current disk assignment.
4128   F105             ;
4129   F105             GETCRNT:
4130   F105 3A 42 E7    	LD	A,(ACTIVE)
4131   F108 C3 01 E7    	JP	SETSTAT
4132   F10B             ;
4133   F10B             ;-------------------------------------------------------------
4134   F10B             ;   Function to set the dma address.
4135   F10B             ;
4136   F10B             PUTDMA:
4137   F10B EB          	EX	DE,HL
4138   F10C 22 B2 F1    	LD	(USERDMA),HL	;save in our space and then get to
4139   F10F C3 DA E9    	JP	DEFDMA		;the bios with this also.
4140   F112             ;
4141   F112             ;-------------------------------------------------------------
4142   F112             ;   Function to return the allocation vector.
4143   F112             ;
4144   F112             GETALOC:
4145   F112 2A C0 F1    	LD	HL,(ALOCVECT)
4146   F115 C3 2A F1    	JP	GETPRM1
4147   F118             ;
4148   F118             ;-------------------------------------------------------------
4149   F118             ;   Function to return the read-only status vector.
4150   F118             ;
4151   F118             GETROV:
4152   F118 2A AE F1    	LD	HL,(WRTPRT)
4153   F11B C3 2A F1    	JP	GETPRM1
4154   F11E             ;
4155   F11E             ;-------------------------------------------------------------
4156   F11E             ;   Function to set the file attributes (read-only, system).
4157   F11E             ;
4158   F11E             SETATTR:
4159   F11E CD 51 F0    	CALL	AUTOSEL		;select proper drive then save attributes.
4160   F121 CD 3B EC    	CALL	SAVEATTR
4161   F124 C3 01 EB    	JP	STSTATUS
4162   F127             ;
4163   F127             ;-------------------------------------------------------------
4164   F127             ;   Function to return the address of the disk parameter block
4165   F127             ; for the current drive.
4166   F127             ;
4167   F127             GETPARM:
4168   F127 2A BC F1    	LD	HL,(DISKPB)
4169   F12A             GETPRM1:
4170   F12A 22 45 E7    	LD	(STATUS),HL
4171   F12D C9          	RET	
4172   F12E             ;
4173   F12E             ;-------------------------------------------------------------
4174   F12E             ;   Function to get or set the user number. If (E) was (FF)
4175   F12E             ; then this is a request to return the current user number.
4176   F12E             ; Else set the user number from (E).
4177   F12E             ;
4178   F12E             GETUSER:
4179   F12E 3A D7 F1    	LD	A,(EPARAM)	;get parameter.
4180   F131 FE FF       	CP	0FFH		;get user number?
4181   F133 C2 3C F1    	JP	NZ,SETUSER
4182   F136 3A 41 E7    	LD	A,(USERNO)	;yes, just do it.
TASM Z80 Assembler.               cpm22.z80                        page 76
 CP/M Ver 2.2 BDOS

4183   F139 C3 01 E7    	JP	SETSTAT
4184   F13C             SETUSER:
4185   F13C E6 1F       	AND	1FH		;no, we should set it instead. keep low
4186   F13E 32 41 E7    	LD	(USERNO),A	;bits (0-4) only.
4187   F141 C9          	RET	
4188   F142             ;
4189   F142             ;-------------------------------------------------------------
4190   F142             ;   Function to read a random record from a file.
4191   F142             ;
4192   F142             RDRANDOM:
4193   F142 CD 51 F0    	CALL	AUTOSEL		;select proper drive and read.
4194   F145 C3 93 EF    	JP	READRAN
4195   F148             ;
4196   F148             ;-------------------------------------------------------------
4197   F148             ;   Function to compute the file size for random files.
4198   F148             ;
4199   F148             WTRANDOM:
4200   F148 CD 51 F0    	CALL	AUTOSEL		;select proper drive and write.
4201   F14B C3 9C EF    	JP	WRITERAN
4202   F14E             ;
4203   F14E             ;-------------------------------------------------------------
4204   F14E             ;   Function to compute the size of a random file.
4205   F14E             ;
4206   F14E             FILESIZE:
4207   F14E CD 51 F0    	CALL	AUTOSEL		;select proper drive and check file length
4208   F151 C3 D2 EF    	JP	RANSIZE
4209   F154             ;
4210   F154             ;-------------------------------------------------------------
4211   F154             ;   Function #37. This allows a program to log off any drives.
4212   F154             ; On entry, set (DE) to contain a word with bits set for those
4213   F154             ; drives that are to be logged off. The log-in vector and the
4214   F154             ; write protect vector will be updated. This must be a M/PM
4215   F154             ; special function.
4216   F154             ;
4217   F154             LOGOFF:
4218   F154 2A 43 E7    	LD	HL,(PARAMS)	;get drives to log off.
4219   F157 7D          	LD	A,L		;for each bit that is set, we want
4220   F158 2F          	CPL			;to clear that bit in (LOGIN)
4221   F159 5F          	LD	E,A		;and (WRTPRT).
4222   F15A 7C          	LD	A,H
4223   F15B 2F          	CPL	
4224   F15C 2A B0 F1    	LD	HL,(LOGIN)	;reset the login vector.
4225   F15F A4          	AND	H
4226   F160 57          	LD	D,A
4227   F161 7D          	LD	A,L
4228   F162 A3          	AND	E
4229   F163 5F          	LD	E,A
4230   F164 2A AE F1    	LD	HL,(WRTPRT)
4231   F167 EB          	EX	DE,HL
4232   F168 22 B0 F1    	LD	(LOGIN),HL	;and save.
4233   F16B 7D          	LD	A,L		;now do the write protect vector.
4234   F16C A3          	AND	E
4235   F16D 6F          	LD	L,A
4236   F16E 7C          	LD	A,H
4237   F16F A2          	AND	D
4238   F170 67          	LD	H,A
4239   F171 22 AE F1    	LD	(WRTPRT),HL	;and save. all done.
4240   F174 C9          	RET	
4241   F175             ;
TASM Z80 Assembler.               cpm22.z80                        page 77
 CP/M Ver 2.2 BDOS

4242   F175             ;-------------------------------------------------------------
4243   F175             ;   Get here to return to the user.
4244   F175             ;
4245   F175             GOBACK:
4246   F175 3A DF F1    	LD	A,(AUTO)	;was auto select activated?
4247   F178 B7          	OR	A
4248   F179 CA 92 F1    	JP	Z,GOBACK1
4249   F17C 2A 43 E7    	LD	HL,(PARAMS)	;yes, but was a change made?
4250   F17F 36 00       	LD	(HL),0		;(* reset first byte of fcb *)
4251   F181 3A E1 F1    	LD	A,(AUTOFLAG)
4252   F184 B7          	OR	A
4253   F185 CA 92 F1    	JP	Z,GOBACK1
4254   F188 77          	LD	(HL),A		;yes, reset first byte properly.
4255   F189 3A E0 F1    	LD	A,(OLDDRV)	;and get the old drive and select it.
4256   F18C 32 D7 F1    	LD	(EPARAM),A
4257   F18F CD 45 F0    	CALL	SETDSK
4258   F192             GOBACK1:
4259   F192 2A 0F E7    	LD	HL,(USRSTACK)	;reset the users stack pointer.
4260   F195 F9          	LD	SP,HL
4261   F196 2A 45 E7    	LD	HL,(STATUS)	;get return status.
4262   F199 7D          	LD	A,L		;force version 1.4 compatability.
4263   F19A 44          	LD	B,H
4264   F19B C9          	RET			;and go back to user.
4265   F19C             ;
4266   F19C             ;-------------------------------------------------------------
4267   F19C             ;   Function #40. This is a special entry to do random i/o.
4268   F19C             ; For the case where we are writing to unused disk space, this
4269   F19C             ; space will be zeroed out first. This must be a M/PM special
4270   F19C             ; purpose function, because why would any normal program even
4271   F19C             ; care about the previous contents of a sector about to be
4272   F19C             ; written over.
4273   F19C             ;
4274   F19C             WTSPECL:
4275   F19C CD 51 F0    	CALL	AUTOSEL		;select proper drive.
4276   F19F 3E 02       	LD	A,2		;use special write mode.
4277   F1A1 32 D6 F1    	LD	(MODE),A
4278   F1A4 0E 00       	LD	C,0		;set write indicator.
4279   F1A6 CD 07 EF    	CALL	POSITN1		;position the file.
4280   F1A9 CC 03 EE    	CALL	Z,WTSEQ1	;and write (if no errors).
4281   F1AC C9          	RET	
TASM Z80 Assembler.               cpm22.z80                        page 78
 CP/M Ver 2.2 BDOS

4282   F1AD             	.EJECT
4283   F1AD             ;
4284   F1AD             ;**************************************************************
4285   F1AD             ;*
4286   F1AD             ;*     BDOS data storage pool.
4287   F1AD             ;*
4288   F1AD             ;**************************************************************
4289   F1AD             ;
4290   F1AD             EMPTYFCB:
4291   F1AD E5          	.BYTE	0E5H		;empty directory segment indicator.
4292   F1AE             WRTPRT:
4293   F1AE 00 00       	.WORD	0		;write protect status for all 16 drives.
4294   F1B0             LOGIN:
4295   F1B0 00 00       	.WORD	0		;drive active word (1 bit per drive).
4296   F1B2             USERDMA:
4297   F1B2 80 00       	.WORD	080H		;user's dma address (defaults to 80h).
4298   F1B4             ;
4299   F1B4             ;-------------------------------------------------------------
4300   F1B4             ;   Scratch areas from parameter block.
4301   F1B4             ;
4302   F1B4             SCRATCH1:
4303   F1B4 00 00       	.WORD	0		;relative position within dir segment for file (0-3).
4304   F1B6             SCRATCH2:
4305   F1B6 00 00       	.WORD	0		;last selected track number.
4306   F1B8             SCRATCH3:
4307   F1B8 00 00       	.WORD	0		;last selected sector number.
4308   F1BA             ;
4309   F1BA             ;-------------------------------------------------------------
4310   F1BA             ;   Disk storage areas from parameter block.
4311   F1BA             ;
4312   F1BA             DIRBUF:
4313   F1BA 00 00       	.WORD	0		;address of directory buffer to use.
4314   F1BC             DISKPB:
4315   F1BC 00 00       	.WORD	0		;contains address of disk parameter block.
4316   F1BE             CHKVECT:
4317   F1BE 00 00       	.WORD	0		;address of check vector.
4318   F1C0             ALOCVECT:
4319   F1C0 00 00       	.WORD	0		;address of allocation vector (bit map).
4320   F1C2             ;
4321   F1C2             ;-------------------------------------------------------------
4322   F1C2             ;   Parameter block returned from the bios.
4323   F1C2             ;
4324   F1C2             SECTORS:
4325   F1C2 00 00       	.WORD	0		;sectors per track from bios.
4326   F1C4             BLKSHFT:
4327   F1C4 00          	.BYTE	0		;block shift.
4328   F1C5             BLKMASK:
4329   F1C5 00          	.BYTE	0		;block mask.
4330   F1C6             EXTMASK:
4331   F1C6 00          	.BYTE	0		;extent mask.
4332   F1C7             DSKSIZE:
4333   F1C7 00 00       	.WORD	0		;disk size from bios (number of blocks-1).
4334   F1C9             DIRSIZE:
4335   F1C9 00 00       	.WORD	0		;directory size.
4336   F1CB             ALLOC0:
4337   F1CB 00 00       	.WORD	0		;storage for first bytes of bit map (dir space used).
4338   F1CD             ALLOC1:
4339   F1CD 00 00       	.WORD	0
4340   F1CF             OFFSET:
TASM Z80 Assembler.               cpm22.z80                        page 79
 CP/M Ver 2.2 BDOS

4341   F1CF 00 00       	.WORD	0		;first usable track number.
4342   F1D1             XLATE:
4343   F1D1 00 00       	.WORD	0		;sector translation table address.
4344   F1D3             ;
4345   F1D3             ;-------------------------------------------------------------
4346   F1D3             ;
4347   F1D3             CLOSEFLG:
4348   F1D3 00          	.BYTE	0		;close flag (=0ffh is extent written ok).
4349   F1D4             RDWRTFLG:
4350   F1D4 00          	.BYTE	0		;read/write flag (0ffh=read, 0=write).
4351   F1D5             FNDSTAT:
4352   F1D5 00          	.BYTE	0		;filename found status (0=found first entry).
4353   F1D6             MODE:
4354   F1D6 00          	.BYTE	0		;I/o mode select (0=random, 1=sequential, 2=special random).
4355   F1D7             EPARAM:
4356   F1D7 00          	.BYTE	0		;storage for register (E) on entry to bdos.
4357   F1D8             RELBLOCK:
4358   F1D8 00          	.BYTE	0		;relative position within fcb of block number written.
4359   F1D9             COUNTER:
4360   F1D9 00          	.BYTE	0		;byte counter for directory name searches.
4361   F1DA             SAVEFCB:
4362   F1DA 00 00 00 00 	.WORD	0,0		;save space for address of fcb (for directory searches).
4363   F1DE             BIGDISK:
4364   F1DE 00          	.BYTE	0		;if =0 then disk is > 256 blocks long.
4365   F1DF             AUTO:
4366   F1DF 00          	.BYTE	0		;if non-zero, then auto select activated.
4367   F1E0             OLDDRV:
4368   F1E0 00          	.BYTE	0		;on auto select, storage for previous drive.
4369   F1E1             AUTOFLAG:
4370   F1E1 00          	.BYTE	0		;if non-zero, then auto select changed drives.
4371   F1E2             SAVNXT:
4372   F1E2 00          	.BYTE	0		;storage for next record number to access.
4373   F1E3             SAVEXT:
4374   F1E3 00          	.BYTE	0		;storage for extent number of file.
4375   F1E4             SAVNREC:
4376   F1E4 00 00       	.WORD	0		;storage for number of records in file.
4377   F1E6             BLKNMBR:
4378   F1E6 00 00       	.WORD	0		;block number (physical sector) used within a file or logical sect
4379   F1E8             LOGSECT:
4380   F1E8 00 00       	.WORD	0		;starting logical (128 byte) sector of block (physical sector).
4381   F1EA             FCBPOS:
4382   F1EA 00          	.BYTE	0		;relative position within buffer for fcb of file of interest.
4383   F1EB             FILEPOS:
4384   F1EB 00 00       	.WORD	0		;files position within directory (0 to max entries -1).
4385   F1ED             ;
4386   F1ED             ;-------------------------------------------------------------
4387   F1ED             ;   Disk directory buffer checksum bytes. One for each of the
4388   F1ED             ; 16 possible drives.
4389   F1ED             ;
4390   F1ED             CKSUMTBL:
4391   F1ED 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
4391   F1F1 00 00 00 00 
4392   F1F5 00 00 00 00 	.BYTE	0,0,0,0,0,0,0,0
4392   F1F9 00 00 00 00 
4393   F1FD             ;
4394   F1FD             ;   Extra space ?
4395   F1FD             ;
4396   F1FD 00 00 00    	.BYTE	0,0,0
4397   F200             ;
TASM Z80 Assembler.               cpm22.z80                        page 80
 CP/M Ver 2.2 BDOS

TASM Z80 Assembler.               cpm22.z80                        page 81
 CP/M Ver 2.2 BDOS

4398   F200             	.EJECT
4399   F200             	.ORG CBASE+1600h
4400   F200             	.TITLE "CP/M BIOS STUB"
TASM Z80 Assembler.               cpm22.z80                        page 82
CP/M BIOS STUB

4401   F200             	.EJECT
4402   F200             ;**************************************************************
4403   F200             ;*
4404   F200             ;*        B I O S   J U M P   T A B L E
4405   F200             ;*
4406   F200             ;**************************************************************
4407   F200             ;
4408   F200             ;labels for the entry points into the BIOS
4409   F200             ;
4410   F200             BOOT:	.BLOCK	3
4411   F203             WBOOT:	.BLOCK	3
4412   F206             CONST:	.BLOCK	3
4413   F209             CONIN:	.BLOCK	3
4414   F20C             CONOUT:	.BLOCK	3
4415   F20F             LIST:	.BLOCK	3
4416   F212             PUNCH:	.BLOCK	3
4417   F215             READER:	.BLOCK	3
4418   F218             HOME:	.BLOCK	3
4419   F21B             SELDSK:	.BLOCK	3
4420   F21E             SETTRK:	.BLOCK	3
4421   F221             SETSEC:	.BLOCK	3
4422   F224             SETDMA:	.BLOCK	3
4423   F227             READ:	.BLOCK	3
4424   F22A             WRITE:	.BLOCK	3
4425   F22D             PRSTAT:	.BLOCK	3
4426   F230             SECTRN:	.BLOCK	3
4427   F233             ;
4428   F233             ;*
4429   F233             ;******************   E N D   O F   C P / M   *****************
4430   F233             ;*
4431   F233             	.END
4432   F233             ;
tasm: Number of errors = 0
